-- [[ INITIALIZATION ]]
if _G.Running then return end
_G.Running = true

-- [[ SERVICES ]]
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local VUser = game:GetService("VirtualUser")
local VInput = game:GetService("VirtualInputManager")
local RepStorage = game:GetService("ReplicatedStorage")

-- [[ CONFIGURATION ]]
local Webhook_URL = "https://discord.com/api/webhooks/1328668957774839819/5-ooyV3yMEsU46cfNtF9NV8a0kyNA0u2Q4xXxeK5HEroIU5yCwqIcmq-8MM7V0bYGBwI"

-- [[ FIELD DATA ]]
local function calcField(v1, v2)
    local center = (v1 + v2) / 2
    return {
        center = center,
        bounds = {
            x1 = math.min(v1.X, v2.X), x2 = math.max(v1.X, v2.X),
            z1 = math.min(v1.Z, v2.Z), z2 = math.max(v1.Z, v2.Z),
            y = center.Y
        }
    }
end

local FieldsData = {
    ["Pine Tree Forest"] = { center = Vector3.new(-330, 70, -190), bounds = {x1 = -375.75, x2 = -284.05, z1 = -251.95, z2 = -128.05} },
    ["Sunflower Field"] = calcField(Vector3.new(-172.129, 3.997, 240.270), Vector3.new(-252.242, 3.997, 108.677)),
    ["Dandelion Field"] = calcField(Vector3.new(-103.944, 3.997, 183.925), Vector3.new(39.818, 3.997, 255.512)),
    ["Clover Field"] = calcField(Vector3.new(104.108, 33.498, 136.491), Vector3.new(207.439, 33.498, 250.944)),
    ["Blue Flower Field"] = calcField(Vector3.new(60.214, 3.997, 128.230), Vector3.new(231.783, 3.997, 64.574)),
    ["Bamboo Field"] = calcField(Vector3.new(207.705, 19.998, -63.421), Vector3.new(52.312, 19.998, 7.943)),
    ["Spider Field"] = calcField(Vector3.new(12.027, 19.998, 36.113), Vector3.new(-98.953, 19.998, -63.378)),
    ["Strawberry Field"] = calcField(Vector3.new(-137.164, 19.998, 39.613), Vector3.new(-222.992, 19.998, -63.411)),
    ["Rose Field"] = calcField(Vector3.new(-267.982, 19.480, 168.147), Vector3.new(-392.378, 19.480, 88.540)),
    ["Cactus Field"] = calcField(Vector3.new(-252.308, 67.790, -139.652), Vector3.new(-124.002, 67.819, -68.288)),
    ["Pumpkin Patch"] = calcField(Vector3.new(-255.686, 67.753, -152.540), Vector3.new(-124.199, 67.425, -219.453)),
    ["Mountain Top"] = calcField(Vector3.new(28.013, 175.982, -111.858), Vector3.new(123.606, 175.924, -223.915)),
    ["Pineapple Patch"] = calcField(Vector3.new(189.510, 67.998, -164.074), Vector3.new(319.320, 67.998, -254.283)),
}

local Boosters = {
    ["Blue Field Booster"] = { pos = Vector3.new(272, 59, 84), collectibles = false, time = 2700 },
    ["Wealth Clock"] = { pos = Vector3.new(330, 50, 191), collectibles = false, time = 3600 },
    ["Stockings"] = { pos = Vector3.new(232, 38, 232), collectibles = true, time = 3600 },
    ["Onett"] = { pos = Vector3.new(34, 236, -512), collectibles = true, time = 28800 },
    ["Glue Dispenser"] = { pos = Vector3.new(270, 25258, -722), collectibles = false, time = 79200 },
    ["Gingerbread House"] = { pos = Vector3.new(-201, 6, 96), collectibles = false, time = 7200 },
    ["Memory Match"] = { pos = Vector3.new(137, 69, -95), collectibles = false, time = 7200, isMM = true },
    ["Mega Memory Match"] = { pos = Vector3.new(-428, 70, -53), collectibles = false, time = 14400, isMM = true },
    ["Night Memory Match"] = { pos = Vector3.new(-17, 312, -270), collectibles = false, time = 28800, isMM = true },
    ["Extreme Memory Match"] = { pos = Vector3.new(-403, 111, 545), collectibles = false, time = 28800, isMM = true }
}

-- [[ GLOBAL STATE ]]
local State = {
    IsFarming = false,
    CurrentField = "Pine Tree Forest",
    LastSprinklerField = "",
    IgnoreBalloonsForever = false,
    BalloonIgnoreUntil = 0,
    TotalMMRewards = {}, 
    InitialBoosterCheckDone = false
}

-- Farming State
local connections = {}
local firstAttemptTimes, permaIgnore, verifyingTokens = {}, {}, {}
local warningDisks = { queue = {}, processing = false }
local crosshairCounter, crosshairBlacklist = 0, {}
local boosterQueue, boosterPermaIgnore = {}, {}
local isCheckingBoosters, isConvertingHoney, activeBooster = false, false, false
local quickRefillCounter, lastEmptiedTime, fullBagTime, waitingForBees = 0, tick(), 0, false
local lastTimeInField, lastWanderPos, lastWanderTime = tick(), nil, 0
local isSolvingMemoryMatch, ActiveMemoryMatchName, lastMMPress = false, nil, 0
local lastHoneyEPress = 0
local currentTarget, currentTargetType = nil, nil

-- Stats
local totalPollenCollected, lastPollenRaw = 0, LocalPlayer.CoreStats.Pollen.Value
local startTime, initialHoney = tick(), LocalPlayer.CoreStats.Honey.Value
local showIntervalStats = false 

-- [[ LOAD EXTERNAL ]]
task.spawn(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    -- disabled cant edit loadstring(game:HttpGet("https://pastes.io/raw/deleteuseless"))()
    -- Wait for the game to fully load
if game:IsLoaded() then
    -- Destroy specific objects once
    local objectsToDestroy = {
        "FlowerZones", "Flowers", "Balloons.FieldBalloons", "Amulets", "Badge Guild",
        "BearShop1", "BoostBalls", "ClassicMinigame", "Decorations",
        "Goo", "Paths"
    }

    for _, objectName in ipairs(objectsToDestroy) do
        local object = game.Workspace:FindFirstChild(objectName, true)
        if object then
            object:Destroy()
        end
    end

    -- Destroy all parts that are DIRECTLY inside Workspace
    for _, instance in ipairs(game.Workspace:GetChildren()) do
        if instance:IsA("Part") then
            instance:Destroy()
        end
    end

    -- Continuously delete balloons inside FieldBalloons every second
    task.spawn(function()
        while true do
            local fieldBalloons = game.Workspace:FindFirstChild("Balloons")
            if fieldBalloons then
                local balloons = fieldBalloons:FindFirstChild("FieldBalloons")
                if balloons then
                    balloons:Destroy() -- Fixed capitalization
                end
            end
            task.wait(0.1) -- Wait 1 second before running again
        end
    end)
end
-------
end)

-- [[ UI LIBRARY ]]
local UI_Stats, UI_Boosters = nil, {}
local function createUI()
    local sg = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
    sg.Name = "BSS_V17_UI"; sg.ResetOnSpawn = false
    local main = Instance.new("Frame", sg)
    main.Name = "MainFrame"; main.Size = UDim2.new(0, 350, 0, 400); main.Position = UDim2.new(0.02, 0, 0.25, 0)
    main.BackgroundColor3 = Color3.fromRGB(15, 15, 15); main.BorderSizePixel = 0; main.Active = true; main.Draggable = true
    local scaleObj = Instance.new("UIScale", main)

    -- Topbar
    local topbar = Instance.new("Frame", main)
    topbar.Size = UDim2.new(1, 0, 0, 35); topbar.BackgroundColor3 = Color3.fromRGB(25, 25, 25); topbar.BorderSizePixel = 0
    local title = Instance.new("TextLabel", topbar)
    title.Size = UDim2.new(0.6, 0, 1, 0); title.Position = UDim2.new(0.02, 0, 0, 0); title.Text = "BSS MASTER V17"; title.TextColor3 = Color3.new(1, 1, 1); title.BackgroundTransparency = 1; title.TextXAlignment = Enum.TextXAlignment.Left; title.Font = Enum.Font.Code; title.TextSize = 16
    local destroyBtn = Instance.new("TextButton", topbar)
    destroyBtn.Size = UDim2.new(0.25, 0, 0.8, 0); destroyBtn.Position = UDim2.new(0.73, 0, 0.1, 0); destroyBtn.BackgroundColor3 = Color3.fromRGB(180, 40, 40); destroyBtn.Text = "DESTROY"; destroyBtn.TextColor3 = Color3.new(1, 1, 1); destroyBtn.Font = Enum.Font.SourceSansBold
    
    local content = Instance.new("Frame", main); content.Size = UDim2.new(1, 0, 0.82, 0); content.Position = UDim2.new(0, 0, 0.18, 0); content.BackgroundTransparency = 1
    local tabContainer = Instance.new("Frame", main); tabContainer.Size = UDim2.new(1, 0, 0, 30); tabContainer.Position = UDim2.new(0, 0, 0.09, 0); tabContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 20); tabContainer.BorderSizePixel = 0
    
    local tabs = {}
    local function switchTab(name) for n, f in pairs(tabs) do f.Visible = (n == name) end end
    local function createTabBtn(name, pos)
        local b = Instance.new("TextButton", tabContainer); b.Size = UDim2.new(0.25, 0, 1, 0); b.Position = UDim2.new(pos, 0, 0, 0); b.BackgroundTransparency = 1; b.Text = name; b.TextColor3 = Color3.new(1,1,1); b.Font = Enum.Font.SourceSansBold
        local frame = Instance.new("ScrollingFrame", content); frame.Size = UDim2.new(1, -10, 1, -10); frame.Position = UDim2.new(0, 5, 0, 5); frame.BackgroundTransparency = 1; frame.ScrollBarThickness = 4; frame.Visible = false
        tabs[name] = frame; local list = Instance.new("UIListLayout", frame); list.Padding = UDim.new(0, 5); list.SortOrder = Enum.SortOrder.LayoutOrder
        b.MouseButton1Click:Connect(function() switchTab(name) end); return frame
    end

    local tabMain = createTabBtn("Dash", 0); local tabStats = createTabBtn("Stats", 0.25); local tabBoosters = createTabBtn("Boost", 0.5); local tabSettings = createTabBtn("Cfg", 0.75)

    -- Dash
    local startBtn = Instance.new("TextButton", tabMain); startBtn.Size = UDim2.new(1, 0, 0, 40); startBtn.BackgroundColor3 = Color3.fromRGB(40, 180, 40); startBtn.Text = "START FARMING"; startBtn.TextColor3 = Color3.new(1,1,1); startBtn.Font = Enum.Font.GothamBold; startBtn.LayoutOrder = 1
    local fieldLabel = Instance.new("TextLabel", tabMain); fieldLabel.Size = UDim2.new(1, 0, 0, 20); fieldLabel.Text = "Select Field:"; fieldLabel.TextColor3 = Color3.new(0.8,0.8,0.8); fieldLabel.BackgroundTransparency = 1; fieldLabel.LayoutOrder = 2
    local fieldScroll = Instance.new("ScrollingFrame", tabMain); fieldScroll.Size = UDim2.new(1, 0, 0, 120); fieldScroll.BackgroundColor3 = Color3.fromRGB(20, 20, 20); fieldScroll.LayoutOrder = 3
    local fsLayout = Instance.new("UIListLayout", fieldScroll); fsLayout.Padding = UDim.new(0,2)
    
    for fname, _ in pairs(FieldsData) do
        local b = Instance.new("TextButton", fieldScroll); b.Size = UDim2.new(1, -10, 0, 25); b.Text = fname; b.BackgroundColor3 = Color3.fromRGB(30, 30, 30); b.TextColor3 = Color3.new(1,1,1)
        b.MouseButton1Click:Connect(function() State.CurrentField = fname; fieldLabel.Text = "Current: " .. fname end)
    end
    fieldScroll.CanvasSize = UDim2.new(0, 0, 0, 14 * 27)

    -- Stats
    local toggleStatsBtn = Instance.new("TextButton", tabStats); toggleStatsBtn.Size = UDim2.new(1, 0, 0, 30); toggleStatsBtn.Text = "View: Total Session"; toggleStatsBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 100); toggleStatsBtn.TextColor3 = Color3.new(1,1,1)
    local statLabels = {}
    local function addStat(id, color) local l = Instance.new("TextLabel", tabStats); l.Size = UDim2.new(1, 0, 0, 20); l.TextColor3 = color or Color3.new(1,1,1); l.BackgroundTransparency = 1; l.TextXAlignment = Enum.TextXAlignment.Left; statLabels[id] = l end
    addStat("HPS"); addStat("HPM"); addStat("HPH"); addStat("PPS", Color3.fromRGB(150,255,150)); addStat("PPM", Color3.fromRGB(150,255,150)); addStat("PPH", Color3.fromRGB(150,255,150)); addStat("Total", Color3.new(1,0.8,0)); addStat("Time")
    local mmHeader = Instance.new("TextLabel", tabStats); mmHeader.Size = UDim2.new(1, 0, 0, 25); mmHeader.Text = "-- MM REWARDS --"; mmHeader.TextColor3 = Color3.new(1,1,0); mmHeader.BackgroundTransparency = 1
    local mmRewLabel = Instance.new("TextLabel", tabStats); mmRewLabel.Size = UDim2.new(1, 0, 0, 500); mmRewLabel.TextYAlignment = Enum.TextYAlignment.Top; mmRewLabel.TextXAlignment = Enum.TextXAlignment.Left; mmRewLabel.BackgroundTransparency = 1; mmRewLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9); mmRewLabel.Text = "No rewards yet."; statLabels.MM = mmRewLabel
    
    toggleStatsBtn.MouseButton1Click:Connect(function() showIntervalStats = not showIntervalStats; toggleStatsBtn.Text = showIntervalStats and "View: Interval (Current)" or "View: Total Session" end)

    -- Boosters
    UI_Boosters = {}
    for bName, _ in pairs(Boosters) do local l = Instance.new("TextLabel", tabBoosters); l.Size = UDim2.new(1, 0, 0, 20); l.Text = bName .. ": Unknown"; l.TextColor3 = Color3.new(0.7, 0.7, 0.7); l.BackgroundTransparency = 1; l.TextXAlignment = Enum.TextXAlignment.Left; UI_Boosters[bName] = l end

    -- Settings
    local scaleBox = Instance.new("TextBox", tabSettings); scaleBox.Size = UDim2.new(1, 0, 0, 30); scaleBox.Text = "UI Scale: 1.0"; scaleBox.BackgroundColor3 = Color3.fromRGB(30,30,30); scaleBox.TextColor3 = Color3.new(1,1,1)
    local balloonTgl = Instance.new("TextButton", tabSettings); balloonTgl.Size = UDim2.new(1, 0, 0, 30); balloonTgl.Text = "Ignore Balloons: OFF"; balloonTgl.BackgroundColor3 = Color3.fromRGB(60, 20, 20); balloonTgl.TextColor3 = Color3.new(1,1,1)
    local balloonTimeBox = Instance.new("TextBox", tabSettings); balloonTimeBox.Size = UDim2.new(1, 0, 0, 30); balloonTimeBox.PlaceholderText = "Ignore for (e.g. 60m, 1h)"; balloonTimeBox.Text = ""; balloonTimeBox.BackgroundColor3 = Color3.fromRGB(30,30,30); balloonTimeBox.TextColor3 = Color3.new(1,1,1)

    scaleBox.FocusLost:Connect(function() local v = tonumber(scaleBox.Text:match("[%d%.]+")); if v then scaleObj.Scale = math.clamp(v, 0.5, 3) end end)
    balloonTgl.MouseButton1Click:Connect(function() State.IgnoreBalloonsForever = not State.IgnoreBalloonsForever; balloonTgl.Text = "Ignore Balloons: " .. (State.IgnoreBalloonsForever and "ON" or "OFF"); balloonTgl.BackgroundColor3 = State.IgnoreBalloonsForever and Color3.fromRGB(20, 60, 20) or Color3.fromRGB(60, 20, 20) end)
    balloonTimeBox.FocusLost:Connect(function() local txt = balloonTimeBox.Text:lower(); local num = tonumber(txt:match("%d+")); if num then local mult = 1; if txt:find("h") then mult = 3600 elseif txt:find("m") then mult = 60 end; State.BalloonIgnoreUntil = tick() + (num * mult); balloonTimeBox.Text = "Ignoring until: " .. os.date("%X", State.BalloonIgnoreUntil) end end)

    startBtn.MouseButton1Click:Connect(function()
        State.IsFarming = not State.IsFarming
        startBtn.Text = State.IsFarming and "STOP FARMING" or "START FARMING"
        startBtn.BackgroundColor3 = State.IsFarming and Color3.fromRGB(180, 40, 40) or Color3.fromRGB(40, 180, 40)
        if State.IsFarming then
            if not State.InitialBoosterCheckDone then isCheckingBoosters = true end
        else
            killMomentum()
        end
    end)

    destroyBtn.MouseButton1Click:Connect(function() _G.Running = false; for _, c in pairs(connections) do c:Disconnect() end; sg:Destroy() end)
    switchTab("Dash")
    return statLabels
end
UI_Stats = createUI()

-- [[ UTILS ]]
local function formatNumber(n) return tostring(math.floor(n)):reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", "") end
local function killMomentum() local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart"); if hrp then hrp.Velocity, hrp.RotVelocity = Vector3.zero, Vector3.zero end end
local function teleportTo(pos) local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart"); if hrp then killMomentum(); hrp.CFrame = CFrame.new(pos) end end
local function pressEKey() VInput:SendKeyEvent(true, Enum.KeyCode.E, false, game); task.wait(0.1); VInput:SendKeyEvent(false, Enum.KeyCode.E, false, game) end

local function isWithinCurrentField(pos)
    local f = FieldsData[State.CurrentField].bounds
    return pos.X >= f.x1 and pos.X <= f.x2 and pos.Z >= f.z1 and pos.Z <= f.z2
end

local function getHivePos()
    local h = workspace:FindFirstChild("Honeycombs")
    if not h then return nil end
    for _, v in ipairs(h:GetChildren()) do 
        local o = v:FindFirstChild("Display") and v.Display:FindFirstChild("Gui") and v.Display.Gui:FindFirstChild("Frame") and v.Display.Gui.Frame:FindFirstChild("OwnerName")
        if o and o.Text == LocalPlayer.Name then return v.Display.Position - Vector3.new(0, 25, 7) end 
    end
    return nil
end

local function parseCooldown(txt)
    local h,m,s = txt:match("(%d+):(%d+):(%d+)"); if h then return tonumber(h)*3600 + tonumber(m)*60 + tonumber(s) end
    local m2,s2 = txt:match("(%d+):(%d+)"); if m2 then return tonumber(m2)*60 + tonumber(s2) end
    return nil
end

local function placeSprinkler()
    if State.CurrentField ~= State.LastSprinklerField then
        local center = FieldsData[State.CurrentField].center
        teleportTo(center)
        task.wait(0.5)
        local args = {{Name = "Sprinkler Builder"}}
        RepStorage.Events.PlayerActivesCommand:FireServer(unpack(args))
        State.LastSprinklerField = State.CurrentField
        task.wait(0.5)
    end
end

-- [[ ASSET NAME CACHE ]]
local AssetNameCache = {}
local function getAssetName(id)
    if AssetNameCache[id] then return AssetNameCache[id] end
    local s, r = pcall(function() return MarketplaceService:GetProductInfo(tonumber(id), Enum.InfoType.Asset).Name end)
    if s then AssetNameCache[id] = r; return r end
    return "ID: " .. tostring(id)
end

-- [[ POLLEN TRACKER ]]
table.insert(connections, RunService.Heartbeat:Connect(function()
    local cur = LocalPlayer.CoreStats.Pollen.Value
    if cur > lastPollenRaw then totalPollenCollected = totalPollenCollected + (cur - lastPollenRaw) end
    lastPollenRaw = cur
end))

-- [[ DISK ENGINE ]]
local function updateDisks()
    local p = workspace:FindFirstChild("Particles"); if not p then return end
    local n = {}
    for _, d in ipairs(p:GetChildren()) do
        if d.Name == "WarningDisk" and d.Size.X <= 8 then
            if not d:GetAttribute("SpawnTime") then d:SetAttribute("SpawnTime", tick()) end
            table.insert(n, d)
        end
    end
    table.sort(n, function(a, b) return (1 - a.Transparency) > (1 - b.Transparency) end)
    warningDisks.queue = n
end

local function processDisks()
    if warningDisks.processing or #warningDisks.queue == 0 then return end
    warningDisks.processing = true
    task.spawn(function()
        while #warningDisks.queue > 0 do
            local d = warningDisks.queue[1]
            if d and d.Parent then
                local spawn = d:GetAttribute("SpawnTime") or tick()
                if d.Transparency > 0.05 then
                    local wait = 1.6 - (tick() - spawn); if wait > 0 then task.wait(wait) end
                end
                if d and d.Parent then
                    local lootStart, timeout = nil, tick()
                    while d and d.Parent and (tick() - timeout < 3) do
                        teleportTo(d.Position + Vector3.new(0, 1, 0))
                        game:GetService("ReplicatedStorage").Events.ToolCollect:FireServer()
                        if d.Transparency <= 0.05 and not lootStart then lootStart = tick() end
                        if lootStart and (tick() - lootStart > 0.14) then break end
                        RunService.Heartbeat:Wait()
                    end
                end
            end
            table.remove(warningDisks.queue, 1); updateDisks()
        end
        warningDisks.processing = false
    end)
end

-- [[ BOOSTER CHECKER ]]
local function checkBoosters()
    local btn = LocalPlayer.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("ActivateButton")
    for name, data in pairs(Boosters) do
        teleportTo(data.pos); task.wait(1.8)
        local bg, txt = btn.BackgroundColor3, btn.TextBox.Text
        local r, g, b = math.round(bg.R*255), math.round(bg.G*255), math.round(bg.B*255)
        local cd = parseCooldown(txt)
        
        if r == 201 and g == 39 and b == 28 and not cd then 
            boosterPermaIgnore[name] = true
            UI_Boosters[name].Text = name .. ": Unavail"
            UI_Boosters[name].TextColor3 = Color3.fromRGB(150,50,50)
        elseif cd then 
            UI_Boosters[name].Text = name .. ": " .. txt
            UI_Boosters[name].TextColor3 = Color3.fromRGB(200,200,0)
            task.delay(cd, function() 
                if not boosterPermaIgnore[name] then 
                    table.insert(boosterQueue, name)
                    UI_Boosters[name].Text = name .. ": READY"
                    UI_Boosters[name].TextColor3 = Color3.fromRGB(50,200,50)
                end 
            end)
        else 
            table.insert(boosterQueue, name)
            UI_Boosters[name].Text = name .. ": READY"
            UI_Boosters[name].TextColor3 = Color3.fromRGB(50,200,50)
        end
    end
    isCheckingBoosters = false; State.InitialBoosterCheckDone = true
    teleportTo(FieldsData[State.CurrentField].center)
end

-- [[ MEMORY MATCH SOLVER ]]
task.spawn(function()
    local KnownCards, SolvedSlots, CurrentBoard = {}, {}, nil
    local GlobalOrderCounter = 0
    local CurrentWinnings = {}
    local DefaultBackID = "http://www.roblox.com/asset/?id=3690982763"
    local function getOrderCounter() GlobalOrderCounter = GlobalOrderCounter + 1; return GlobalOrderCounter end

    local function sendMMWebhook(gameName, winnings)
        if #winnings == 0 then return end
        local fields = {}
        for _, w in ipairs(winnings) do
            local name = getAssetName(w.id)
            local amt = w.count ~= "" and w.count or "x1"
            table.insert(fields, { name = name, value = string.format("Amt: %s", amt), inline = true })
            if not State.TotalMMRewards[w.id] then State.TotalMMRewards[w.id] = 0 end
            State.TotalMMRewards[w.id] = State.TotalMMRewards[w.id] + (tonumber(amt:match("%d+")) or 1)
        end
        local embed = { title = "ðŸŽ‰ " .. (gameName or "MM") .. " Won", color = 16776960, fields = fields }
        pcall(function() request({Url = Webhook_URL, Method = 'POST', Headers = {['Content-Type']='application/json'}, Body = HttpService:JSONEncode({embeds = {embed}})}) end)
    end

    local MMLogic = {
        ["Memory Match"] = {
            Ignore = { ["2028574353"]=true,["1471882621"]=true,["2863122826"]=true, ["8277901755"]=true },
            ListA = { ["1674871631_x5"]=true,["2529092020"]=true, ["2863468407"]=true, ["2584584968"]=true,["2545746569"]=true },
            ListB = { ["2504978518"]=true }
        },
        ["Mega Memory Match"] = {
            Ignore = {["2028574353"]=true, ["1471882621"]=true, ["2863122826"]=true,["8277901755"]=true, ["3012679515"]=true,["3030407727"]=true },
            ListA = {["1674871631_x3"]=true,["2863468407_x3"]=true, ["2545746569"]=true, ["2584584968"]=true,["2542899798"]=true, ["15482935937"]=true },
            ListB = { ["2504978518"]=true,["2319943273"]=true,["1674871631_x10"]=true }
        },
        ["Night Memory Match"] = {
            Ignore = {["2028574353"]=true, ["8277901755"]=true, ["2863122826"]=true },
            ListA = { ["2504978518"]=true,["2314214749"]=true, ["2319943273"]=true },
            ListB = { ["2676671613"]=true,["2028603146"]=true }
        },
        ["Extreme Memory Match"] = {
            Ignore = { ["2028574353"]=true,["1471882621"]=true, ["1838129169"]=true, ["8277901755"]=true },
            ListA = {["2319943273"]=true, ["2542899798"]=true, ["2542899798_x5"]=true,["3835877932"]=true },
            ListB = {["1471850677"]=true, ["1471849394"]=true,["15529301204"]=true,["2028603146"]=true }
        }
    }

    local function extractCount(text) return text and string.match(text:lower(), "x%d+") or "" end
    local function checkCategory(matchType, id, countText)
        local logic = MMLogic[matchType] or MMLogic["Memory Match"]
        local sig = id .. (countText ~= "" and "_" .. countText or "")
        if logic.Ignore[sig] or logic.Ignore[id] then return "Ignore" end
        if logic.ListB[sig] or logic.ListB[id] then return "ListB" end
        if logic.ListA[sig] or logic.ListA[id] then return "ListA" end
        return "Common"
    end

    local function clickSlot(slot)
        for _, desc in pairs(slot:GetDescendants()) do
            if (desc:IsA("ImageButton") or desc:IsA("TextButton")) and getconnections then
                for _, conn in pairs(getconnections(desc.MouseButton1Click)) do conn:Fire() end
                for _, conn in pairs(getconnections(desc.Activated)) do conn:Fire() end
            end
        end
    end

    local function clickAndRead(slot)
        local targetImg = nil
        for _, desc in pairs(slot:GetDescendants()) do
            if desc.Name == "ObjImage" and desc:IsA("ImageLabel") and desc.Image == DefaultBackID then targetImg = desc; break end
        end
        clickSlot(slot)
        if targetImg then
            local waited = 0
            while targetImg.Image == DefaultBackID and waited < 3 do task.wait(0.1); waited = waited + 0.1 end
            if targetImg.Image ~= DefaultBackID then 
                local txtLbl2 = targetImg:FindFirstChild("TextCount")
                return string.match(targetImg.Image, "%d+"), (txtLbl2 and extractCount(txtLbl2.Text) or "")
            end
        else
            task.wait(0.5)
            for _, desc in pairs(slot:GetDescendants()) do
                if desc.Name == "ObjImage" and desc:IsA("ImageLabel") and string.match(desc.Image, "rbxassetid://") then 
                    local txtLbl2 = desc:FindFirstChild("TextCount")
                    return string.match(desc.Image, "%d+"), (txtLbl2 and extractCount(txtLbl2.Text) or "")
                end
            end
        end
        return nil, ""
    end

    local function getActiveBoard()
        local sg = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
        local ml = sg and sg:FindFirstChild("MinigameLayer")
        if not ml then return nil end
        for _, child in pairs(ml:GetChildren()) do
            if child.Name == "MemoryMatchFrame" then
                local lbl = child:FindFirstChild("ChancesFrame") and child.ChancesFrame:FindFirstChild("CountLabel")
                if lbl and (tonumber(string.match(lbl.ContentText, "%d+")) or 0) >= 1 then return child end
            end
        end
        return nil
    end

    local function determineNextAction(matchType, availableSlots)
        local listBMatches, listAMatches, commonMatches = {}, {}, {}
        local idToSlot = {}
        
        for slot, data in pairs(KnownCards) do
            if not SolvedSlots[slot] and data.cat ~= "Ignore" then
                if idToSlot[data.sig] then
                    local pair = {c1 = idToSlot[data.sig], c2 = slot, order = KnownCards[idToSlot[data.sig]].orderSeen}
                    if data.cat == "ListB" then table.insert(listBMatches, pair)
                    elseif data.cat == "ListA" then table.insert(listAMatches, pair)
                    elseif data.cat == "Common" then table.insert(commonMatches, pair) end
                else
                    idToSlot[data.sig] = slot
                end
            end
        end
        
        table.sort(listBMatches, function(a,b) return a.order < b.order end)
        table.sort(listAMatches, function(a,b) return a.order < b.order end)
        table.sort(commonMatches, function(a,b) return a.order < b.order end)
        
        if #listBMatches > 0 then return "Match", listBMatches[1].c1, listBMatches[1].c2 end
        if #listAMatches > 0 then return "Match", listAMatches[1].c1, listAMatches[1].c2 end
        
        local unknowns = {}
        for _, s in ipairs(availableSlots) do if not KnownCards[s] then table.insert(unknowns, s) end end
        
        if #unknowns >= 2 then
            local u1 = table.remove(unknowns, math.random(1, #unknowns))
            local u2 = table.remove(unknowns, math.random(1, #unknowns))
            return "Explore", u1, u2
        elseif #unknowns == 1 then
            local u1 = unknowns[1]
            local anchor = nil
            for s, d in pairs(KnownCards) do if not SolvedSlots[s] and d.cat ~= "Ignore" then anchor = s; break end end
            if not anchor then anchor = availableSlots[1] == u1 and availableSlots[2] or availableSlots[1] end
            return "Explore", u1, anchor
        end
        
        if #commonMatches > 0 then return "Match", commonMatches[1].c1, commonMatches[1].c2 end
        return "Random", availableSlots[1], availableSlots[2]
    end

    local function doTurn(matchType, action, slot1, slot2)
        if action == "Match" or action == "Random" then
            local idA, ctA = clickAndRead(slot1); task.wait(0.2); local idB, ctB = clickAndRead(slot2)
            SolvedSlots[slot1] = true; SolvedSlots[slot2] = true
            if idA then table.insert(CurrentWinnings, {id = idA, count = ctA}) end
            task.wait(1.2)
        elseif action == "Explore" then
            local id1, count1 = clickAndRead(slot1)
            if id1 then
                local sig1 = id1 .. (count1 ~= "" and "_" .. count1 or "")
                KnownCards[slot1] = {id = id1, count = count1, sig = sig1, cat = checkCategory(matchType, id1, count1), orderSeen = getOrderCounter()}
                local pairSlot
                if KnownCards[slot1].cat ~= "Ignore" then
                    for s, d in pairs(KnownCards) do if s ~= slot1 and not SolvedSlots[s] and d.sig == sig1 then pairSlot = s; break end end
                end
                
                if pairSlot then
                    clickSlot(pairSlot); SolvedSlots[slot1] = true; SolvedSlots[pairSlot] = true
                    table.insert(CurrentWinnings, {id = id1, count = count1})
                    task.wait(1.2)
                else
                    local id2, count2 = clickAndRead(slot2)
                    if id2 then
                        local sig2 = id2 .. (count2 ~= "" and "_" .. count2 or "")
                        KnownCards[slot2] = {id = id2, count = count2, sig = sig2, cat = checkCategory(matchType, id2, count2), orderSeen = getOrderCounter()}
                        if sig1 == sig2 and KnownCards[slot2].cat ~= "Ignore" then
                            SolvedSlots[slot1] = true; SolvedSlots[slot2] = true
                            table.insert(CurrentWinnings, {id = id2, count = count2})
                        end
                    end
                    task.wait(1.2)
                end
            else clickSlot(slot2); task.wait(1.2) end
        end
    end

    while _G.Running do
        task.wait(0.1)
        local activeBoard = getActiveBoard()
        if not activeBoard then
            if isSolvingMemoryMatch and tick() - lastMMPress > 5 then
                isSolvingMemoryMatch = false
                sendMMWebhook(ActiveMemoryMatchName, CurrentWinnings)
                ActiveMemoryMatchName = nil; CurrentWinnings = {}
                task.wait(5)
            end
            continue
        end
        
        lastMMPress = tick()
        if activeBoard ~= CurrentBoard then CurrentBoard = activeBoard; KnownCards = {}; SolvedSlots = {}; GlobalOrderCounter = 0; CurrentWinnings = {}; task.wait(1) end
        
        local grid = activeBoard:FindFirstChild("GuiGrid") and activeBoard.GuiGrid:FindFirstChild("GuiGrid")
        if not grid then task.wait(1) continue end
        
        local available = {}
        for _, child in pairs(grid:GetChildren()) do if child:IsA("Frame") and not SolvedSlots[child] then table.insert(available, child) end end
        if #available == 0 then task.wait(2) continue end
        
        local matchType = ActiveMemoryMatchName or "Memory Match"
        local action, slot1, slot2 = determineNextAction(matchType, available)
        doTurn(matchType, action, slot1, slot2)
    end
end)

-- [[ MAIN BACKGROUND CONTROLLER ]]
task.spawn(function()
    while _G.Running do
        task.wait(0.5)
        
        if State.IsFarming then
            -- 1. Scan for Boosters
            if isCheckingBoosters then checkBoosters() end
            
            -- 2. Process Queue
            if #boosterQueue > 0 and not isConvertingHoney and not activeBooster and not warningDisks.processing and not isSolvingMemoryMatch then
                activeBooster = true; local b = table.remove(boosterQueue, 1)
                teleportTo(Boosters[b].pos); task.wait(1.5); pressEKey(); task.wait(0.5)
                
                if Boosters[b].isMM then
                    task.wait(4); ActiveMemoryMatchName = b; isSolvingMemoryMatch = true; lastMMPress = tick()
                    task.delay(Boosters[b].time, function() if not boosterPermaIgnore[b] then table.insert(boosterQueue, b) end end)
                    activeBooster = false; teleportTo(FieldsData[State.CurrentField].center)
                else
                    if Boosters[b].collectibles then
                        local tOut = tick(); repeat task.wait(0.1) until #workspace.Collectibles:GetChildren() > 5 or tick() - tOut > 6
                        local vacStart = tick()
                        while tick() - vacStart < 12 do
                            local nearby = {}
                            for _, t in ipairs(workspace.Collectibles:GetChildren()) do if (t.Position - Boosters[b].pos).Magnitude < 30 then table.insert(nearby, t) end end
                            if #nearby == 0 then break end
                            for _, t in ipairs(nearby) do teleportTo(t.Position); task.wait(0.05) end
                        end
                    end
                    task.delay(Boosters[b].time, function() if not boosterPermaIgnore[b] then table.insert(boosterQueue, b) end end)
                    task.wait(1.5); activeBooster = false; teleportTo(FieldsData[State.CurrentField].center)
                end
            end
        end
        
        -- 3. Update UI
        if UI_Stats then
            local elapsed = math.max(1, tick() - startTime)
            local h = LocalPlayer.CoreStats.Honey.Value - initialHoney
            local hps, pps = h/elapsed, totalPollenCollected/elapsed
            UI_Stats.hS.Text = "H/s: "..formatNumber(hps); UI_Stats.hM.Text = "H/m: "..formatNumber(hps*60); UI_Stats.hH.Text = "H/h: "..formatNumber(hps*3600)
            UI_Stats.pS.Text = "P/s: "..formatNumber(pps); UI_Stats.pM.Text = "P/m: "..formatNumber(pps*60); UI_Stats.pH.Text = "P/h: "..formatNumber(pps*3600)
            UI_Stats.total.Text = "Total: "..formatNumber(h); UI_Stats.time.Text = "Time: "..os.date("!%X", elapsed)
            local mmText = ""
            for id, count in pairs(State.TotalMMRewards) do mmText = mmText .. getAssetName(id) .. ": " .. count .. "\n" end
            UI_Stats.MM.Text = mmText ~= "" and mmText or "No rewards yet."
        end
    end
end)

-- [[ MAIN LOOPS ]]
table.insert(connections, RunService.RenderStepped:Connect(function()
    if not _G.Running or not State.IsFarming then return end
    
    local char = LocalPlayer.Character
    local hrp, hum = char and char:FindFirstChild("HumanoidRootPart"), char and char:FindFirstChild("Humanoid")
    if not hrp or isCheckingBoosters or activeBooster or isSolvingMemoryMatch then return end

    if not State.SprinklerPlaced then placeSprinkler() end
    if #warningDisks.queue > 0 or warningDisks.processing then processDisks(); return end

    local pol, cap = LocalPlayer.CoreStats.Pollen.Value, LocalPlayer.CoreStats.Capacity.Value
    if not isConvertingHoney then
        if pol >= cap then
            if not waitingForBees then waitingForBees = true; fullBagTime = tick() end
            if tick() - fullBagTime >= 5 then 
                isConvertingHoney = true; waitingForBees = false
                local hP = getHivePos(); if hP then teleportTo(hP); RepStorage.Events.ItemPackageEvent:InvokeServer("Equip", {["Category"] = "Accessory", ["Type"] = "Honey Mask"}); task.wait(1); RepStorage.Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking") end
            end
        else waitingForBees = false end
    else
        local balloonNear = false
        if not State.IgnoreBalloonsForever and tick() > State.BalloonIgnoreUntil then
            for _, b in ipairs(workspace.Balloons.HiveBalloons:GetDescendants()) do if b.Name == "BalloonBody" and (b.Position - hrp.Position).Magnitude < 30 then balloonNear = true break end end
        end
        if pol == 0 then if balloonNear then task.wait(5); isConvertingHoney = false; teleportTo(FieldsData[State.CurrentField].center) end end
        if LocalPlayer.PlayerGui.ScreenGui.ActivateButton.TextBox.Text:find("Pollen From Flower Fields") then
            RepStorage.Events.ItemPackageEvent:InvokeServer("Equip", {["Category"] = "Accessory", ["Type"] = "Diamond Mask"}); isConvertingHoney = false; teleportTo(FieldsData[State.CurrentField].center)
        end
        return
    end

    game:GetService("ReplicatedStorage").Events.ToolCollect:FireServer()
    local res = {}
    for _, p in ipairs(workspace.Collectibles:GetChildren()) do
        if p:IsA("Part") and not verifyingTokens[p] and not permaIgnore[p] then
            if math.abs(p.Position.Y - hrp.Position.Y) > 5 then permaIgnore[p] = true continue end
            if firstAttemptTimes[p] and (tick() - firstAttemptTimes[p] > 8) then permaIgnore[p] = true continue end
            if isWithinCurrentField(p.Position) then table.insert(res, {part = p, priority = 4, type = "Token"}) end
        end
    end
    for _, p in ipairs(workspace.Particles:GetChildren()) do
        if p.Name == "Crosshair" and not crosshairBlacklist[p] and isWithinCurrentField(p.Position) then
            crosshairCounter = crosshairCounter + 1
            if crosshairCounter % 3 == 0 then crosshairBlacklist[p] = true else table.insert(res, {part = p, priority = 1, type = "Crosshair"}) end
        end
    end
    table.sort(res, function(a,b) return a.priority < b.priority end)

    if not currentTarget or verifyingTokens[currentTarget] or not currentTarget.Parent then
        currentTarget = #res > 0 and res[1].part or nil; currentTargetType = #res > 0 and res[1].type or nil
        if currentTarget and not firstAttemptTimes[currentTarget] then firstAttemptTimes[currentTarget] = tick() end
    end

    if currentTarget then
        if currentTargetType == "Crosshair" then
            hum:MoveTo(currentTarget.Position)
            if (hrp.Position - currentTarget.Position).Magnitude < 3 then
                killMomentum(); local t = tick(); while currentTarget and currentTarget.Parent and tick() - t < 4 do game:GetService("ReplicatedStorage").Events.ToolCollect:FireServer(); RunService.Heartbeat:Wait() end
                crosshairBlacklist[currentTarget] = true; currentTarget = nil
            end
        else
            local dest = currentTarget.Position + (currentTarget.Position - hrp.Position).Unit * 4
            local f = FieldsData[State.CurrentField].bounds
            hum:MoveTo(Vector3.new(math.clamp(dest.X, f.x1, f.x2), hrp.Position.Y, math.clamp(dest.Z, f.z1, f.z2)))
            if (hrp.Position - dest).Magnitude < 2.5 then verifyingTokens[currentTarget] = tick(); currentTarget = nil end
        end
    else
        if not lastWanderPos or (hrp.Position - lastWanderPos).Magnitude < 5 or tick() - lastWanderTime > 8 then
            local f = FieldsData[State.CurrentField].bounds
            lastWanderPos = Vector3.new(math.random(f.x1, f.x2), hrp.Position.Y, math.random(f.z1, f.z2)); lastWanderTime = tick()
        end
        hum:MoveTo(lastWanderPos)
    end
end))

-- [[ WEBHOOK ]]
task.spawn(function()
    while _G.Running do task.wait(300); local elapsed = math.max(1, tick() - startTime); local h = LocalPlayer.CoreStats.Honey.Value - initialHoney; local hps, pps = h/elapsed, totalPollenCollected/elapsed
        local embeds = {{title = "BSS MASTER UPDATE", color = 0x00A2FF, fields = {{name = "Honey (S/M/H)", value = string.format("%s | %s | %s", formatNumber(hps), formatNumber(hps*60), formatNumber(hps*3600))}, {name = "Pollen (S/M/H)", value = string.format("%s | %s | %s", formatNumber(pps), formatNumber(pps*60), formatNumber(pps*3600))}, {name = "Total Honey", value = formatNumber(h), inline = true}, {name = "Runtime", value = os.date("!%X", elapsed), inline = true}}, timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")}}
        pcall(function() local req = (syn and syn.request) or (http and http.request) or request; req({Url = Webhook_URL, Method = 'POST', Headers = {['Content-Type']='application/json'}, Body = HttpService:JSONEncode({embeds = embeds})}) end)
    end
end)

-- [[ FAILSAFES ]]
table.insert(connections, RunService.Heartbeat:Connect(function()
    if not _G.Running or not State.IsFarming then return end
    updateDisks()
    local char = LocalPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    if isConvertingHoney then
        local activateBtn = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("ActivateButton")
        if activateBtn and activateBtn:FindFirstChild("TextBox") then
            if activateBtn.TextBox.Text:lower() == "make honey" and tick() - lastHoneyEPress > 5 then lastHoneyEPress = tick(); killMomentum(); pressEKey() end
        end
        local hPos = getHivePos()
        if hPos then if (Vector2.new(hrp.Position.X - hPos.X, hrp.Position.Z - hPos.Z).Magnitude > 5 or math.abs(hrp.Position.Y - hPos.Y) > 30) then teleportTo(hPos) end end
        return 
    end

    if not isCheckingBoosters and not activeBooster and not isSolvingMemoryMatch then
        if not isWithinCurrentField(hrp.Position) then
            if tick() - lastTimeInField > 10 then teleportTo(FieldsData[State.CurrentField].center); lastTimeInField = tick() end
        else lastTimeInField = tick() end
    end
    for t, time in pairs(verifyingTokens) do if not t.Parent or math.abs(t.Orientation.X) > 20 or tick() - time > 1.2 then verifyingTokens[t] = nil end end
end))

-- Anti-Idle
table.insert(connections, LocalPlayer.Idled:Connect(function() VUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame); task.wait(1); VUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame) end))
print("âœ… BSS V17: Full Release Loaded.")
