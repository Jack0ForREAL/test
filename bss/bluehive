-- [[ BSS MASTER V22 - Based on V16 with new features ]]
-- Features added over V16:
--   * Manual Start/Stop farming from UI (does NOT auto-start on execution)
--   * Field selector dropdown (all fields)
--   * Auto-sprinkler on new field (once per field change)
--   * Ignore balloon converting: forever toggle + timed ignore (e.g. 60m, 1h)
--   * MM rewards total persists for entire execution session
--   * Booster tab shows cooldown times
--   * "Replace" button to toggle H/s between session total vs interval
--   * Revamped tabbed UI

if _G.Running then return end
_G.Running = true

-- [[ SERVICES ]]
local Players             = game:GetService("Players")
local RunService          = game:GetService("RunService")
local HttpService         = game:GetService("HttpService")
local MarketplaceService  = game:GetService("MarketplaceService")
local VUser               = game:GetService("VirtualUser")
local VInput              = game:GetService("VirtualInputManager")
local RepStorage          = game:GetService("ReplicatedStorage")
local LocalPlayer         = Players.LocalPlayer

local connections = {}

-- [[ EXTERNAL LIBS ]]
task.spawn(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    -- disabled cant edit loadstring(game:HttpGet("https://pastes.io/raw/deleteuseless"))()
    -- Wait for the game to fully load
if game:IsLoaded() then
    -- Destroy specific objects once
    local objectsToDestroy = {
        "FlowerZones", "Flowers", "Balloons.FieldBalloons", "Amulets", "Badge Guild",
        "BearShop1", "BoostBalls", "ClassicMinigame", "Decorations",
        "Goo", "Paths"
    }

    for _, objectName in ipairs(objectsToDestroy) do
        local object = game.Workspace:FindFirstChild(objectName, true)
        if object then
            object:Destroy()
        end
    end

    -- Destroy all parts that are DIRECTLY inside Workspace
    for _, instance in ipairs(game.Workspace:GetChildren()) do
        if instance:IsA("Part") then
            instance:Destroy()
        end
    end

    -- Continuously delete balloons inside FieldBalloons every second
    task.spawn(function()
        while true do
            local fieldBalloons = game.Workspace:FindFirstChild("Balloons")
            if fieldBalloons then
                local balloons = fieldBalloons:FindFirstChild("FieldBalloons")
                if balloons then
                    balloons:Destroy() -- Fixed capitalization
                end
            end
            task.wait(0.1) -- Wait 1 second before running again
        end
    end)
end
-------
end)

-- =============================================================================
-- [[ 1. CONSTANTS & DATA ]]
-- =============================================================================
local Webhook_URL = "https://discord.com/api/webhooks/1328668957774839819/5-ooyV3yMEsU46cfNtF9NV8a0kyNA0u2Q4xXxeK5HEroIU5yCwqIcmq-8MM7V0bYGBwI"

-- Helper: compute bounds and center from two corner vectors
local function calcField(v1, v2)
    local cx = (v1.X + v2.X) / 2
    local cy = (v1.Y + v2.Y) / 2
    local cz = (v1.Z + v2.Z) / 2
    return {
        center = Vector3.new(cx, cy, cz),
        bounds = {
            x1 = math.min(v1.X, v2.X), x2 = math.max(v1.X, v2.X),
            z1 = math.min(v1.Z, v2.Z), z2 = math.max(v1.Z, v2.Z)
        }
    }
end

local FieldsData = {
    ["Pine Tree Forest"]  = { center = Vector3.new(-330, 70, -190),  bounds = {x1=-375.75, x2=-284.05, z1=-251.95, z2=-128.05} },
    ["Sunflower Field"]   = calcField(Vector3.new(-172.129,3.997,240.270),  Vector3.new(-252.242,3.997,108.677)),
    ["Dandelion Field"]   = calcField(Vector3.new(-103.944,3.997,183.925),  Vector3.new(39.818,3.997,255.512)),
    ["Clover Field"]      = calcField(Vector3.new(104.108,33.498,136.491),  Vector3.new(207.439,33.498,250.944)),
    ["Blue Flower Field"] = calcField(Vector3.new(60.214,3.997,128.230),    Vector3.new(231.783,3.997,64.574)),
    ["Bamboo Field"]      = calcField(Vector3.new(207.705,19.998,-63.421),  Vector3.new(52.312,19.998,7.943)),
    ["Spider Field"]      = calcField(Vector3.new(12.027,19.998,36.113),    Vector3.new(-98.953,19.998,-63.378)),
    ["Strawberry Field"]  = calcField(Vector3.new(-137.164,19.998,39.613),  Vector3.new(-222.992,19.998,-63.411)),
    ["Rose Field"]        = calcField(Vector3.new(-267.982,19.480,168.147), Vector3.new(-392.378,19.480,88.540)),
    ["Cactus Field"]      = calcField(Vector3.new(-252.308,67.790,-139.652),Vector3.new(-124.002,67.819,-68.288)),
    ["Pumpkin Patch"]     = calcField(Vector3.new(-255.686,67.753,-152.540),Vector3.new(-124.199,67.425,-219.453)),
    ["Mountain Top"]      = calcField(Vector3.new(28.013,175.982,-111.858), Vector3.new(123.606,175.924,-223.915)),
    ["Pineapple Patch"]   = calcField(Vector3.new(189.510,67.998,-164.074), Vector3.new(319.320,67.998,-254.283)),
}

-- Ordered list for UI
local FieldOrder = {
    "Pine Tree Forest","Sunflower Field","Dandelion Field","Clover Field",
    "Blue Flower Field","Bamboo Field","Spider Field","Strawberry Field",
    "Rose Field","Cactus Field","Pumpkin Patch","Mountain Top","Pineapple Patch"
}

local Boosters = {
    ["Blue Field Booster"]  = { pos = Vector3.new(272,59,84),        collectibles = false, time = 2700  },
    ["Wealth Clock"]        = { pos = Vector3.new(330,50,191),       collectibles = false, time = 3600  },
    ["Stockings"]           = { pos = Vector3.new(232,38,232),       collectibles = true,  time = 3600  },
    ["Onett"]               = { pos = Vector3.new(34,236,-512),      collectibles = true,  time = 28800 },
    ["Glue Dispenser"]      = { pos = Vector3.new(270,25258,-722),   collectibles = false, time = 79200 },
    ["Gingerbread House"]   = { pos = Vector3.new(-201,6,96),        collectibles = false, time = 7200  },
    ["Memory Match"]        = { pos = Vector3.new(137,69,-95),       collectibles = false, time = 7200,  isMM = true },
    ["Mega Memory Match"]   = { pos = Vector3.new(-428,70,-53),      collectibles = false, time = 14400, isMM = true },
    ["Night Memory Match"]  = { pos = Vector3.new(-17,312,-270),     collectibles = false, time = 28800, isMM = true },
    ["Extreme Memory Match"]= { pos = Vector3.new(-403,111,545),     collectibles = false, time = 28800, isMM = true },
}

-- =============================================================================
-- [[ 2. STATE ]]
-- =============================================================================
local firstAttemptTimes, permaIgnore, verifyingTokens = {}, {}, {}
local totalPollenCollected = 0
local lastPollenRaw        = LocalPlayer.CoreStats.Pollen.Value
local startTime            = tick()
local initialHoney         = LocalPlayer.CoreStats.Honey.Value

-- Interval honey tracking (for "Replace" toggle)
local intervalHoneyStart   = LocalPlayer.CoreStats.Honey.Value
local intervalStartTime    = tick()
local showIntervalStats    = false   -- false = session total, true = interval

local lastHoneyEPress      = 0

local warningDisks         = { queue = {}, processing = false }
local crosshairCounter, crosshairBlacklist = 0, {}
local boosterQueue, boosterPermaIgnore = {}, {}
local boosterCooldownLabels = {}  -- name -> label reference

local isCheckingBoosters   = false  -- set true briefly during initial scan
local isConvertingHoney    = false
local activeBooster        = false
local quickRefillCounter   = 0
local lastEmptiedTime      = tick()
local fullBagTime          = 0
local waitingForBees       = false
local lastTimeInField      = tick()
local lastWanderPos, lastWanderTime = nil, 0
local currentTarget, currentTargetType = nil, nil

-- Memory Match state
local isSolvingMemoryMatch = false
local ActiveMemoryMatchName = nil
local lastMMPress          = 0

-- Farming state (manual start/stop)
local isFarming            = false

-- Current field
local currentFieldName     = "Pine Tree Forest"

-- Sprinkler: track which field has the sprinkler placed THIS session
local sprinklerFieldName   = ""   -- empty = none placed yet

-- Balloon ignore
local ignoreBalloonForever = false
local ignoreBalloonUntil   = 0    -- tick() deadline; 0 = not set

-- MM rewards (persist for entire script execution)
local totalMMRewards       = {}   -- [assetID] = totalCount

-- CSV telemetry
local statsBuffer, tilesBuffer = {}, {}
local lastSaveTime         = tick()
local SAVE_INTERVAL        = 15
local tilesFilename        = "Tiles.txt"

local function generateFilename(base)
    local d = os.date("*t")
    return string.format("%s-%d-%d-%d_%d%s.csv", base, d.year, d.month, d.day, d.hour, d.hour<12 and "am" or "pm")
end
local statsFile       = generateFilename("TelementBSS")
local tilesOutputFile = generateFilename("TelementBSSTiles")

local function flushBuffers()
    if #statsBuffer > 0 then
        local data = table.concat(statsBuffer, "\n")
        if isfile(statsFile) then appendfile(statsFile, "\n"..data) else writefile(statsFile, "Time,TotalHoney,HPS,Pollen,PPS,Capacity\n"..data) end
        statsBuffer = {}
    end
    if #tilesBuffer > 0 then
        local data = table.concat(tilesBuffer, "\n")
        if isfile(tilesOutputFile) then appendfile(tilesOutputFile, "\n"..data) else writefile(tilesOutputFile, "Time,TileID,Multiplier,State\n"..data) end
        tilesBuffer = {}
    end
end

local function loadTileIDs()
    if not isfile(tilesFilename) then return {} end
    local ids = {}
    for line in readfile(tilesFilename):gmatch("%S+") do ids[line] = true end
    return ids
end
local monitoredTiles = loadTileIDs()
local tileStates     = {}

-- =============================================================================
-- [[ 3. UTILITIES ]]
-- =============================================================================
local function formatNumber(n)
    return tostring(math.floor(n)):reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,","")
end

local function killMomentum()
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if hrp then hrp.Velocity = Vector3.zero; hrp.RotVelocity = Vector3.zero end
end

local function teleportTo(pos)
    local char = LocalPlayer.Character
    local hrp  = char and char:FindFirstChild("HumanoidRootPart")
    local hum  = char and char:FindFirstChild("Humanoid")
    if hrp then
        killMomentum()
        hrp.CFrame = CFrame.new(pos)
        if hum then hum:MoveTo(hrp.Position) end  -- cancels any active MoveTo destination
    end
end

local function pressEKey()
    VInput:SendKeyEvent(true,  Enum.KeyCode.E, false, game)
    task.wait(0.1)
    VInput:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

local function getFieldBounds()  return FieldsData[currentFieldName].bounds  end
local function getFieldCenter()  return FieldsData[currentFieldName].center   end

local function isWithinField(pos)
    local b = getFieldBounds()
    return pos.X >= b.x1 and pos.X <= b.x2 and pos.Z >= b.z1 and pos.Z <= b.z2
end

local function getHivePos()
    local h = workspace:FindFirstChild("Honeycombs")
    if not h then return nil end
    for _, v in ipairs(h:GetChildren()) do
        local o = v:FindFirstChild("Display") and v.Display:FindFirstChild("Gui")
              and v.Display.Gui:FindFirstChild("Frame") and v.Display.Gui.Frame:FindFirstChild("OwnerName")
        if o and o.Text == LocalPlayer.Name then
            return v.Display.Position - Vector3.new(0, 25, 7)
        end
    end
    return nil
end

local function parseCooldown(txt)
    local h,m,s = txt:match("(%d+):(%d+):(%d+)")
    if h then return tonumber(h)*3600 + tonumber(m)*60 + tonumber(s) end
    local m2,s2 = txt:match("(%d+):(%d+)")
    if m2 then return tonumber(m2)*60 + tonumber(s2) end
    return nil
end

-- Place sprinkler at the center of the current field (only if not already placed for this field)
local function placeSprinkler()
    if sprinklerFieldName == currentFieldName then return end  -- already placed for this field
    teleportTo(getFieldCenter())
    task.wait(0.6)
    RepStorage.Events.PlayerActivesCommand:FireServer({Name = "Sprinkler Builder"})
    sprinklerFieldName = currentFieldName
    task.wait(0.4)
end

-- =============================================================================
-- [[ 4. UI ]]
-- =============================================================================
local UI_Stats     = {}
local boosterUILabels = {}

local function createUI()
    -- Destroy any old UI
    local old = LocalPlayer.PlayerGui:FindFirstChild("BSS_V22_UI")
    if old then old:Destroy() end

    local sg   = Instance.new("ScreenGui", LocalPlayer.PlayerGui)
    sg.Name    = "BSS_V22_UI"
    sg.ResetOnSpawn = false

    local main = Instance.new("Frame", sg)
    main.Name  = "Main"
    main.Size  = UDim2.new(0, 310, 0, 400)
    main.Position  = UDim2.new(0.02, 0, 0.2, 0)
    main.BackgroundColor3 = Color3.fromRGB(12, 12, 14)
    main.BorderSizePixel  = 0
    main.Active   = true
    main.Draggable = true

    local uiScale = Instance.new("UIScale", main)

    -- ---- TOP BAR ----
    local topbar = Instance.new("Frame", main)
    topbar.Size  = UDim2.new(1,0,0,32)
    topbar.BackgroundColor3 = Color3.fromRGB(22, 22, 28)
    topbar.BorderSizePixel  = 0

    local titleLbl = Instance.new("TextLabel", topbar)
    titleLbl.Size  = UDim2.new(0.65,0,1,0)
    titleLbl.Position = UDim2.new(0.02,0,0,0)
    titleLbl.Text  = "BSS MASTER V22"
    titleLbl.TextColor3 = Color3.fromRGB(220,220,255)
    titleLbl.BackgroundTransparency = 1
    titleLbl.TextXAlignment = Enum.TextXAlignment.Left
    titleLbl.Font  = Enum.Font.Code
    titleLbl.TextSize = 15

    local destroyBtn = Instance.new("TextButton", topbar)
    destroyBtn.Size  = UDim2.new(0.28,0,0.78,0)
    destroyBtn.Position = UDim2.new(0.70,0,0.11,0)
    destroyBtn.BackgroundColor3 = Color3.fromRGB(180,40,40)
    destroyBtn.Text  = "DESTROY"
    destroyBtn.TextColor3  = Color3.new(1,1,1)
    destroyBtn.Font  = Enum.Font.SourceSansBold
    destroyBtn.TextSize = 13
    destroyBtn.BorderSizePixel = 0

    -- ---- TAB BAR ----
    local tabBar = Instance.new("Frame", main)
    tabBar.Size  = UDim2.new(1,0,0,26)
    tabBar.Position = UDim2.new(0,0,0,32)
    tabBar.BackgroundColor3 = Color3.fromRGB(18,18,22)
    tabBar.BorderSizePixel  = 0

    -- ---- CONTENT AREA ----
    local contentArea = Instance.new("Frame", main)
    contentArea.Size = UDim2.new(1,0,1,-58)
    contentArea.Position = UDim2.new(0,0,0,58)
    contentArea.BackgroundTransparency = 1
    contentArea.ClipsDescendants = true

    -- ---- SCALE BOX (bottom) ----
    local scaleBox = Instance.new("TextBox", main)
    scaleBox.Size  = UDim2.new(0.5,0,0,18)
    scaleBox.Position = UDim2.new(0.01,0,0.955,0)
    scaleBox.BackgroundColor3 = Color3.fromRGB(25,25,30)
    scaleBox.Text  = "Scale:1.0"
    scaleBox.TextColor3 = Color3.fromRGB(160,160,180)
    scaleBox.Font  = Enum.Font.Code
    scaleBox.TextSize = 11
    scaleBox.BorderSizePixel = 0
    scaleBox.FocusLost:Connect(function()
        local v = tonumber(scaleBox.Text:match("[%d%.]+"))
        if v then uiScale.Scale = math.clamp(v, 0.4, 2.5) end
    end)

    -- ===== TAB SYSTEM =====
    local tabFrames = {}
    local tabButtons = {}
    local tabNames = {"Dash","Stats","Boost","Cfg"}

    local function switchTab(name)
        for n, f in pairs(tabFrames) do
            f.Visible = (n == name)
            f.Active  = (n == name)  -- CRITICAL: hidden frames still eat input without this
        end
        for n, b in pairs(tabButtons) do
            b.BackgroundColor3 = (n==name) and Color3.fromRGB(45,45,60) or Color3.fromRGB(18,18,22)
            b.TextColor3 = (n==name) and Color3.fromRGB(220,220,255) or Color3.fromRGB(130,130,150)
        end
    end

    for i, tname in ipairs(tabNames) do
        local btn = Instance.new("TextButton", tabBar)
        btn.Size = UDim2.new(0.25, 0, 1, 0)
        btn.Position = UDim2.new(0.25*(i-1), 0, 0, 0)
        btn.BackgroundColor3 = Color3.fromRGB(18,18,22)
        btn.BorderSizePixel  = 0
        btn.Text = tname
        btn.TextColor3 = Color3.fromRGB(130,130,150)
        btn.Font = Enum.Font.SourceSansBold
        btn.TextSize = 13
        tabButtons[tname] = btn

        local sf = Instance.new("ScrollingFrame", contentArea)
        sf.Size = UDim2.new(1,-4,1,-4)
        sf.Position = UDim2.new(0,2,0,2)
        sf.BackgroundTransparency = 1
        sf.ScrollBarThickness = 3
        sf.ScrollBarImageColor3 = Color3.fromRGB(80,80,120)
        sf.Visible = false
        sf.Active  = false   -- don't block input when hidden
        sf.CanvasSize = UDim2.new(0,0,0,600)
        sf.AutomaticCanvasSize = Enum.AutomaticSize.Y
        local layout = Instance.new("UIListLayout", sf)
        layout.Padding = UDim.new(0,4)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        tabFrames[tname] = sf
        tabButtons[tname].MouseButton1Click:Connect(function() switchTab(tname) end)
    end

    -- Helper to make a label row
    local function makeLabel(parent, text, color, order)
        local l = Instance.new("TextLabel", parent)
        l.Size = UDim2.new(1,-6,0,20)
        l.BackgroundTransparency = 1
        l.Text = text
        l.TextColor3 = color or Color3.new(1,1,1)
        l.Font = Enum.Font.Code
        l.TextSize = 13
        l.TextXAlignment = Enum.TextXAlignment.Left
        l.LayoutOrder = order or 0
        return l
    end

    local function makeButton(parent, text, color, order)
        local b = Instance.new("TextButton", parent)
        b.Size = UDim2.new(1,-6,0,26)
        b.BackgroundColor3 = color or Color3.fromRGB(40,40,55)
        b.BorderSizePixel = 0
        b.Text = text
        b.TextColor3 = Color3.new(1,1,1)
        b.Font = Enum.Font.SourceSansBold
        b.TextSize = 13
        b.LayoutOrder = order or 0
        return b
    end

    local function makeDivider(parent, order)
        local d = Instance.new("Frame", parent)
        d.Size = UDim2.new(1,-6,0,1)
        d.BackgroundColor3 = Color3.fromRGB(45,45,60)
        d.BorderSizePixel = 0
        d.LayoutOrder = order or 0
        return d
    end

    -- ===========================
    -- DASH TAB
    -- ===========================
    local dash = tabFrames["Dash"]

    local startBtn = makeButton(dash, "‚ñ∂  START FARMING", Color3.fromRGB(30,140,60), 1)
    startBtn.Size = UDim2.new(1,-6,0,34)

    makeDivider(dash, 2)
    makeLabel(dash, "  Field:", Color3.fromRGB(160,160,200), 3)

    -- Field selector scroll list
    local fieldScroll = Instance.new("ScrollingFrame", dash)
    fieldScroll.Size = UDim2.new(1,-6,0,130)
    fieldScroll.BackgroundColor3 = Color3.fromRGB(18,18,24)
    fieldScroll.BorderSizePixel = 0
    fieldScroll.ScrollBarThickness = 3
    fieldScroll.ScrollBarImageColor3 = Color3.fromRGB(80,80,120)
    fieldScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
    fieldScroll.CanvasSize = UDim2.new(0,0,0,0)
    fieldScroll.LayoutOrder = 4
    local fsLayout = Instance.new("UIListLayout", fieldScroll)
    fsLayout.Padding = UDim.new(0,2)

    local fieldBtns = {}
    local function updateFieldButtons()
        for fname, btn in pairs(fieldBtns) do
            if fname == currentFieldName then
                btn.BackgroundColor3 = Color3.fromRGB(40,80,40)
                btn.TextColor3 = Color3.fromRGB(150,255,150)
            else
                btn.BackgroundColor3 = Color3.fromRGB(22,22,28)
                btn.TextColor3 = Color3.fromRGB(180,180,200)
            end
        end
    end

    for _, fname in ipairs(FieldOrder) do
        local fb = Instance.new("TextButton", fieldScroll)
        fb.Size = UDim2.new(1,-4,0,22)
        fb.BackgroundColor3 = Color3.fromRGB(22,22,28)
        fb.BorderSizePixel = 0
        fb.Text = "  "..fname
        fb.TextColor3 = Color3.fromRGB(180,180,200)
        fb.Font = Enum.Font.Code
        fb.TextSize = 12
        fb.TextXAlignment = Enum.TextXAlignment.Left
        fieldBtns[fname] = fb
        fb.MouseButton1Click:Connect(function()
            currentFieldName = fname
            sprinklerFieldName = ""  -- force re-place when farming resumes
            updateFieldButtons()
        end)
    end
    updateFieldButtons()

    makeDivider(dash, 5)

    local statusLbl = makeLabel(dash, "  Status: Idle", Color3.fromRGB(160,160,100), 6)
    local fieldActiveLbl = makeLabel(dash, "  Field: "..currentFieldName, Color3.fromRGB(140,200,140), 7)

    -- Wire start button
    startBtn.MouseButton1Click:Connect(function()
        isFarming = not isFarming
        if isFarming then
            startBtn.Text = "‚ñ†  STOP FARMING"
            startBtn.BackgroundColor3 = Color3.fromRGB(160,40,40)
            statusLbl.Text = "  Status: Farming"
            intervalHoneyStart = LocalPlayer.CoreStats.Honey.Value
            intervalStartTime  = tick()
            -- trigger booster check if not done or if we want fresh check
            if not isCheckingBoosters then
                isCheckingBoosters = true
                task.spawn(function()
                    local btn2 = LocalPlayer.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("ActivateButton")
                    for name, data in pairs(Boosters) do
                        if boosterPermaIgnore[name] then continue end
                        teleportTo(data.pos); task.wait(1.8)
                        -- Cancel movement after teleport during scan too
                        local _sc = LocalPlayer.Character
                        local _sh = _sc and _sc:FindFirstChild("Humanoid")
                        local _sr = _sc and _sc:FindFirstChild("HumanoidRootPart")
                        if _sh and _sr then _sh:MoveTo(_sr.Position) end
                        local bg, txt = btn2.BackgroundColor3, btn2.TextBox.Text
                        local cd = parseCooldown(txt)  -- works on "Spend ... (x:xx:xx)" too
                        local r,g,b2 = math.round(bg.R*255), math.round(bg.G*255), math.round(bg.B*255)
                        -- "Spend X honey" text means cost-gated (not on time cooldown) ‚Äî treat as unavailable for now
                        local isSpendGated = txt:lower():find("spend") ~= nil and not cd
                        if (r==201 and g==39 and b2==28 and not cd) or isSpendGated then
                            boosterPermaIgnore[name] = true
                            if boosterUILabels[name] then
                                boosterUILabels[name].Text = "  "..name..":  [Unavailable]"
                                boosterUILabels[name].TextColor3 = Color3.fromRGB(120,60,60)
                            end
                        elseif cd then
                            -- Show clean time, not the full raw button text
                            local timeStr = string.format("%dh %dm %ds", math.floor(cd/3600), math.floor((cd%3600)/60), cd%60)
                            if boosterUILabels[name] then
                                boosterUILabels[name].Text = "  "..name..":  ‚è≥ "..timeStr
                                boosterUILabels[name].TextColor3 = Color3.fromRGB(200,180,60)
                            end
                            task.delay(cd, function()
                                if not boosterPermaIgnore[name] then
                                    table.insert(boosterQueue, name)
                                    if boosterUILabels[name] then
                                        boosterUILabels[name].Text = "  "..name..":  ‚úÖ READY"
                                        boosterUILabels[name].TextColor3 = Color3.fromRGB(80,220,80)
                                    end
                                end
                            end)
                        else
                            table.insert(boosterQueue, name)
                            if boosterUILabels[name] then
                                boosterUILabels[name].Text = "  "..name..":  ‚úÖ READY"
                                boosterUILabels[name].TextColor3 = Color3.fromRGB(80,220,80)
                            end
                        end
                    end
                    isCheckingBoosters = false
                    teleportTo(getFieldCenter())
                end)
            end
            teleportTo(getFieldCenter())
        else
            startBtn.Text = "‚ñ∂  START FARMING"
            startBtn.BackgroundColor3 = Color3.fromRGB(30,140,60)
            statusLbl.Text = "  Status: Idle"
            killMomentum()
        end
    end)

    -- ===========================
    -- STATS TAB
    -- ===========================
    local statsTab = tabFrames["Stats"]

    -- Toggle button
    local toggleBtn = makeButton(statsTab, "View: Session Total", Color3.fromRGB(35,55,100), 1)

    makeDivider(statsTab, 2)

    local hS  = makeLabel(statsTab, "  H/s:  0",    Color3.fromRGB(255,220,100), 3)
    local hM  = makeLabel(statsTab, "  H/m:  0",    Color3.fromRGB(255,220,100), 4)
    local hH  = makeLabel(statsTab, "  H/h:  0",    Color3.fromRGB(255,220,100), 5)
    makeDivider(statsTab, 6)
    local pS  = makeLabel(statsTab, "  P/s:  0",    Color3.fromRGB(100,200,255), 7)
    local pM  = makeLabel(statsTab, "  P/m:  0",    Color3.fromRGB(100,200,255), 8)
    local pH  = makeLabel(statsTab, "  P/h:  0",    Color3.fromRGB(100,200,255), 9)
    makeDivider(statsTab, 10)
    local totalLbl = makeLabel(statsTab, "  Total Honey:  0", Color3.fromRGB(255,200,60), 11)
    local timeLbl  = makeLabel(statsTab, "  Runtime:  00:00:00", nil, 12)
    makeDivider(statsTab, 13)
    local mmHeader = makeLabel(statsTab, "  ‚îÄ‚îÄ MM REWARDS ‚îÄ‚îÄ", Color3.fromRGB(255,255,80), 14)
    local mmLbl    = makeLabel(statsTab, "  No rewards yet.", Color3.fromRGB(200,200,200), 15)
    mmLbl.Size     = UDim2.new(1,-6,0,160)
    mmLbl.TextYAlignment = Enum.TextYAlignment.Top

    toggleBtn.MouseButton1Click:Connect(function()
        showIntervalStats = not showIntervalStats
        toggleBtn.Text = showIntervalStats and "View: Interval (since last start)" or "View: Session Total"
        intervalHoneyStart = LocalPlayer.CoreStats.Honey.Value
        intervalStartTime  = tick()
    end)

    UI_Stats = {
        hS  = hS,  hM  = hM,  hH  = hH,
        pS  = pS,  pM  = pM,  pH  = pH,
        total = totalLbl, time = timeLbl,
        mm    = mmLbl,
        fieldActive = fieldActiveLbl,
        status      = statusLbl,
    }

    -- ===========================
    -- BOOST TAB
    -- ===========================
    local boostTab = tabFrames["Boost"]
    makeLabel(boostTab, "  ‚îÄ‚îÄ Booster Status ‚îÄ‚îÄ", Color3.fromRGB(255,220,100), 1)
    makeDivider(boostTab, 2)

    local boosterOrder = {
        "Blue Field Booster","Wealth Clock","Stockings","Gingerbread House",
        "Memory Match","Mega Memory Match","Night Memory Match","Extreme Memory Match",
        "Onett","Glue Dispenser"
    }
    for i, bName in ipairs(boosterOrder) do
        local lbl = makeLabel(boostTab, "  "..bName..":  Unknown", Color3.fromRGB(160,160,180), i+2)
        boosterUILabels[bName] = lbl
    end

    -- ===========================
    -- CFG TAB
    -- ===========================
    local cfgTab = tabFrames["Cfg"]
    makeLabel(cfgTab, "  ‚îÄ‚îÄ Balloon Ignoring ‚îÄ‚îÄ", Color3.fromRGB(200,200,255), 1)

    local balloonForeverBtn = makeButton(cfgTab, "Ignore Balloon: OFF", Color3.fromRGB(80,30,30), 2)
    balloonForeverBtn.MouseButton1Click:Connect(function()
        ignoreBalloonForever = not ignoreBalloonForever
        balloonForeverBtn.Text = "Ignore Balloon: " .. (ignoreBalloonForever and "ON (Forever)" or "OFF")
        balloonForeverBtn.BackgroundColor3 = ignoreBalloonForever and Color3.fromRGB(30,80,30) or Color3.fromRGB(80,30,30)
    end)

    local balloonTimeLbl = makeLabel(cfgTab, "  Ignore for duration:", Color3.fromRGB(160,160,180), 3)

    local balloonTimeBox = Instance.new("TextBox", cfgTab)
    balloonTimeBox.Size = UDim2.new(1,-6,0,26)
    balloonTimeBox.BackgroundColor3 = Color3.fromRGB(22,22,30)
    balloonTimeBox.Text = ""
    balloonTimeBox.PlaceholderText = "e.g. 30m, 2h, 90m ..."
    balloonTimeBox.TextColor3 = Color3.fromRGB(200,200,220)
    balloonTimeBox.PlaceholderColor3 = Color3.fromRGB(90,90,110)
    balloonTimeBox.Font = Enum.Font.Code
    balloonTimeBox.TextSize = 12
    balloonTimeBox.BorderSizePixel = 0
    balloonTimeBox.LayoutOrder = 4

    local balloonStatusLbl = makeLabel(cfgTab, "  Timed ignore: inactive", Color3.fromRGB(120,180,120), 5)

    balloonTimeBox.FocusLost:Connect(function()
        local txt = balloonTimeBox.Text:lower():gsub("%s","")
        local num = tonumber(txt:match("%d+"))
        if num then
            local secs = num
            if txt:find("h") then secs = num * 3600
            elseif txt:find("m") then secs = num * 60
            end
            ignoreBalloonUntil = tick() + secs
            balloonStatusLbl.Text = "  Ignoring until: "..os.date("%H:%M:%S", os.time() + secs)
            balloonStatusLbl.TextColor3 = Color3.fromRGB(100,220,100)
        end
    end)

    makeDivider(cfgTab, 6)
    makeLabel(cfgTab, "  ‚îÄ‚îÄ UI Scale ‚îÄ‚îÄ", Color3.fromRGB(200,200,255), 7)
    local scfgBox = Instance.new("TextBox", cfgTab)
    scfgBox.Size = UDim2.new(1,-6,0,26)
    scfgBox.BackgroundColor3 = Color3.fromRGB(22,22,30)
    scfgBox.Text = "1.0"
    scfgBox.PlaceholderText = "Scale (0.4 ‚Äì 2.5)"
    scfgBox.TextColor3 = Color3.fromRGB(200,200,220)
    scfgBox.Font = Enum.Font.Code
    scfgBox.TextSize = 12
    scfgBox.BorderSizePixel = 0
    scfgBox.LayoutOrder = 8
    scfgBox.FocusLost:Connect(function()
        local v = tonumber(scfgBox.Text:match("[%d%.]+"))
        if v then uiScale.Scale = math.clamp(v, 0.4, 2.5) end
    end)

    -- Destroy button logic
    destroyBtn.MouseButton1Click:Connect(function()
        _G.Running = false
        for _, c in pairs(connections) do c:Disconnect() end
        sg:Destroy()
        print("[BSS V22] Stopped.")
    end)

    switchTab("Dash")
end

createUI()

-- =============================================================================
-- [[ 5. POLLEN WATCHER ]]
-- =============================================================================
table.insert(connections, RunService.Heartbeat:Connect(function()
    local cur = LocalPlayer.CoreStats.Pollen.Value
    if cur > lastPollenRaw then totalPollenCollected = totalPollenCollected + (cur - lastPollenRaw) end
    lastPollenRaw = cur
end))

-- =============================================================================
-- [[ 6. MEMORY LEAK CLEANUP ]]
-- =============================================================================
task.spawn(function()
    while _G.Running do
        task.wait(30)
        local function purge(tbl)
            for k in pairs(tbl) do
                if typeof(k) == "Instance" and not k.Parent then tbl[k] = nil end
            end
        end
        purge(permaIgnore); purge(firstAttemptTimes); purge(verifyingTokens); purge(crosshairBlacklist)
    end
end)

-- =============================================================================
-- [[ 7. MEMORY MATCH SOLVER ]]
-- =============================================================================
task.spawn(function()
    local KnownCards, SolvedSlots, CurrentBoard = {}, {}, nil
    local GlobalOrderCounter = 0
    local CurrentWinnings    = {}
    local AssetNameCache     = {}
    local DefaultBackID      = "http://www.roblox.com/asset/?id=3690982763"

    local function getOrderCounter() GlobalOrderCounter = GlobalOrderCounter + 1; return GlobalOrderCounter end

    local function getAssetName(id)
        if AssetNameCache[id] then return AssetNameCache[id] end
        local ok, name = pcall(function()
            return MarketplaceService:GetProductInfo(tonumber(id), Enum.InfoType.Asset).Name
        end)
        if ok then AssetNameCache[id] = name; return name end
        return "Asset "..tostring(id)
    end

    local function sendMMWebhook(gameName, winnings)
        if #winnings == 0 then return end
        local fields = {}
        for _, w in ipairs(winnings) do
            local name = getAssetName(w.id)
            local amt  = w.count ~= "" and w.count or "x1"
            table.insert(fields, {name=name, value="Amount: "..amt, inline=true})
            -- accumulate totals
            local cnt = tonumber((amt:match("%d+"))) or 1
            totalMMRewards[w.id] = (totalMMRewards[w.id] or 0) + cnt
        end
        local embed = {
            title  = "üéâ "..(gameName or "Memory Match").." Winnings",
            color  = 16776960,
            fields = fields,
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }
        pcall(function()
            local req = (syn and syn.request) or (http and http.request) or request
            req({Url=Webhook_URL, Method='POST', Headers={['Content-Type']='application/json'}, Body=HttpService:JSONEncode({embeds={embed}})})
        end)
    end

    local MMLogic = {
        ["Memory Match"] = {
            Ignore = {["2028574353"]=true,["1471882621"]=true,["2863122826"]=true,["8277901755"]=true},
            ListA  = {["1674871631_x5"]=true,["2529092020"]=true,["2863468407"]=true,["2584584968"]=true,["2545746569"]=true},
            ListB  = {["2504978518"]=true}
        },
        ["Mega Memory Match"] = {
            Ignore = {["2028574353"]=true,["1471882621"]=true,["2863122826"]=true,["8277901755"]=true,["3012679515"]=true,["3030407727"]=true},
            ListA  = {["1674871631_x3"]=true,["2863468407_x3"]=true,["2545746569"]=true,["2584584968"]=true,["2542899798"]=true,["15482935937"]=true},
            ListB  = {["2504978518"]=true,["2319943273"]=true,["1674871631_x10"]=true}
        },
        ["Night Memory Match"] = {
            Ignore = {["2028574353"]=true,["8277901755"]=true,["2863122826"]=true},
            ListA  = {["2504978518"]=true,["2314214749"]=true,["2319943273"]=true},
            ListB  = {["2676671613"]=true,["2028603146"]=true}
        },
        ["Extreme Memory Match"] = {
            Ignore = {["2028574353"]=true,["1471882621"]=true,["1838129169"]=true,["8277901755"]=true},
            ListA  = {["2319943273"]=true,["2542899798"]=true,["2542899798_x5"]=true,["3835877932"]=true},
            ListB  = {["1471850677"]=true,["1471849394"]=true,["15529301204"]=true,["2028603146"]=true}
        }
    }

    local function extractCount(text)
        if not text then return "" end
        return string.match(text:lower(), "x%d+") or ""
    end

    local function checkCategory(matchType, id, countText)
        local logic = MMLogic[matchType] or MMLogic["Memory Match"]
        local sig = id .. (countText ~= "" and "_"..countText or "")
        if logic.Ignore[sig] or logic.Ignore[id] then return "Ignore" end
        if logic.ListB[sig]  or logic.ListB[id]  then return "ListB"  end
        if logic.ListA[sig]  or logic.ListA[id]  then return "ListA"  end
        return "Common"
    end

    local function clickSlot(slot)
        for _, desc in pairs(slot:GetDescendants()) do
            if (desc:IsA("ImageButton") or desc:IsA("TextButton")) and getconnections then
                for _, conn in pairs(getconnections(desc.MouseButton1Click)) do conn:Fire() end
                for _, conn in pairs(getconnections(desc.Activated))       do conn:Fire() end
            end
        end
    end

    local function clickAndRead(slot)
        local targetImg = nil
        for _, desc in pairs(slot:GetDescendants()) do
            if desc.Name == "ObjImage" and desc:IsA("ImageLabel") and desc.Image == DefaultBackID then
                targetImg = desc; break
            end
        end
        clickSlot(slot)
        if targetImg then
            local waited = 0
            while targetImg.Image == DefaultBackID and waited < 3 do task.wait(0.1); waited += 0.1 end
            if targetImg.Image ~= DefaultBackID then
                local txtLbl = targetImg:FindFirstChild("TextCount")
                return string.match(targetImg.Image, "%d+"), (txtLbl and extractCount(txtLbl.Text) or "")
            end
        else
            task.wait(0.5)
            for _, desc in pairs(slot:GetDescendants()) do
                if desc.Name == "ObjImage" and desc:IsA("ImageLabel") and desc.Image:match("rbxassetid://") then
                    local txtLbl = desc:FindFirstChild("TextCount")
                    return string.match(desc.Image, "%d+"), (txtLbl and extractCount(txtLbl.Text) or "")
                end
            end
        end
        return nil, ""
    end

    local function getActiveBoard()
        local sg2 = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
        local ml  = sg2 and sg2:FindFirstChild("MinigameLayer")
        if not ml then return nil end
        for _, child in pairs(ml:GetChildren()) do
            if child.Name == "MemoryMatchFrame" then
                local lbl = child:FindFirstChild("ChancesFrame") and child.ChancesFrame:FindFirstChild("CountLabel")
                if lbl and (tonumber(string.match(lbl.ContentText, "%d+")) or 0) >= 1 then return child end
            end
        end
        return nil
    end

    local function determineNextAction(matchType, availableSlots)
        local listBMatches, listAMatches, commonMatches = {}, {}, {}
        local idToSlot = {}
        for slot, data in pairs(KnownCards) do
            if not SolvedSlots[slot] and data.cat ~= "Ignore" then
                if idToSlot[data.sig] then
                    local pair = {c1=idToSlot[data.sig], c2=slot, order=KnownCards[idToSlot[data.sig]].orderSeen}
                    if data.cat=="ListB" then table.insert(listBMatches, pair)
                    elseif data.cat=="ListA" then table.insert(listAMatches, pair)
                    else table.insert(commonMatches, pair) end
                else
                    idToSlot[data.sig] = slot
                end
            end
        end
        table.sort(listBMatches, function(a,b) return a.order < b.order end)
        table.sort(listAMatches, function(a,b) return a.order < b.order end)
        table.sort(commonMatches,function(a,b) return a.order < b.order end)

        if #listBMatches > 0 then return "Match", listBMatches[1].c1, listBMatches[1].c2 end
        if #listAMatches > 0 then return "Match", listAMatches[1].c1, listAMatches[1].c2 end

        local unknowns = {}
        for _, s in ipairs(availableSlots) do if not KnownCards[s] then table.insert(unknowns, s) end end

        if #unknowns >= 2 then
            local u1 = table.remove(unknowns, math.random(1,#unknowns))
            local u2 = table.remove(unknowns, math.random(1,#unknowns))
            return "Explore", u1, u2
        elseif #unknowns == 1 then
            local u1 = unknowns[1]
            local anchor
            for s, d in pairs(KnownCards) do if not SolvedSlots[s] and d.cat~="Ignore" then anchor=s; break end end
            if not anchor then anchor = (availableSlots[1]==u1) and availableSlots[2] or availableSlots[1] end
            return "Explore", u1, anchor
        end

        if #commonMatches > 0 then return "Match", commonMatches[1].c1, commonMatches[1].c2 end
        return "Random", availableSlots[1], availableSlots[2]
    end

    local function doTurn(matchType, action, slot1, slot2)
        if action == "Match" or action == "Random" then
            local idA, ctA = clickAndRead(slot1); task.wait(0.2)
            local idB, ctB = clickAndRead(slot2)
            SolvedSlots[slot1] = true; SolvedSlots[slot2] = true
            if idA then table.insert(CurrentWinnings, {id=idA, count=ctA}) end
            task.wait(1.2)
        elseif action == "Explore" then
            local id1, count1 = clickAndRead(slot1)
            if id1 then
                local sig1 = id1 .. (count1~="" and "_"..count1 or "")
                KnownCards[slot1] = {id=id1, count=count1, sig=sig1, cat=checkCategory(matchType,id1,count1), orderSeen=getOrderCounter()}
                local pairSlot
                if KnownCards[slot1].cat ~= "Ignore" then
                    for s, d in pairs(KnownCards) do
                        if s~=slot1 and not SolvedSlots[s] and d.sig==sig1 then pairSlot=s; break end
                    end
                end
                if pairSlot then
                    clickSlot(pairSlot)
                    SolvedSlots[slot1] = true; SolvedSlots[pairSlot] = true
                    table.insert(CurrentWinnings, {id=id1, count=count1})
                    task.wait(1.2)
                else
                    local id2, count2 = clickAndRead(slot2)
                    if id2 then
                        local sig2 = id2 .. (count2~="" and "_"..count2 or "")
                        KnownCards[slot2] = {id=id2, count=count2, sig=sig2, cat=checkCategory(matchType,id2,count2), orderSeen=getOrderCounter()}
                        if sig1==sig2 and KnownCards[slot2].cat~="Ignore" then
                            SolvedSlots[slot1]=true; SolvedSlots[slot2]=true
                            table.insert(CurrentWinnings, {id=id2, count=count2})
                        end
                    end
                    task.wait(1.2)
                end
            else
                clickSlot(slot2); task.wait(1.2)
            end
        end
    end

    while _G.Running do
        task.wait(0.1)
        local activeBoard = getActiveBoard()
        if not activeBoard then
            if isSolvingMemoryMatch and tick() - lastMMPress > 5 then
                isSolvingMemoryMatch = false
                sendMMWebhook(ActiveMemoryMatchName, CurrentWinnings)
                -- Schedule re-queue for the booster
                if ActiveMemoryMatchName and Boosters[ActiveMemoryMatchName] then
                    local bName = ActiveMemoryMatchName
                    task.delay(Boosters[bName].time, function()
                        if not boosterPermaIgnore[bName] then
                            table.insert(boosterQueue, bName)
                            if boosterUILabels[bName] then
                                boosterUILabels[bName].Text = "  "..bName..":  ‚úÖ READY"
                                boosterUILabels[bName].TextColor3 = Color3.fromRGB(80,220,80)
                            end
                        end
                    end)
                    -- Update label to show cooldown
                    local bTime = Boosters[bName].time
                    local timeStr = string.format("%dh %dm", math.floor(bTime/3600), math.floor((bTime%3600)/60))
                    if boosterUILabels[bName] then
                        boosterUILabels[bName].Text = "  "..bName..":  ‚è≥ "..timeStr
                        boosterUILabels[bName].TextColor3 = Color3.fromRGB(200,180,60)
                    end
                end
                ActiveMemoryMatchName = nil
                CurrentWinnings = {}
                task.wait(5)
            end
            continue
        end

        lastMMPress = tick()
        if activeBoard ~= CurrentBoard then
            CurrentBoard=activeBoard; KnownCards={}; SolvedSlots={}; GlobalOrderCounter=0; CurrentWinnings={}
            task.wait(1)
        end

        local grid = activeBoard:FindFirstChild("GuiGrid") and activeBoard.GuiGrid:FindFirstChild("GuiGrid")
        if not grid then task.wait(1) continue end

        local available = {}
        for _, child in pairs(grid:GetChildren()) do
            if child:IsA("Frame") and not SolvedSlots[child] then table.insert(available, child) end
        end
        if #available == 0 then task.wait(2) continue end

        local matchType = ActiveMemoryMatchName or "Memory Match"
        local action, slot1, slot2 = determineNextAction(matchType, available)
        doTurn(matchType, action, slot1, slot2)
    end
end)

-- =============================================================================
-- [[ 8. DISK ENGINE ]]
-- =============================================================================
local function updateDisks()
    local p = workspace:FindFirstChild("Particles"); if not p then return end
    local n = {}
    for _, d in ipairs(p:GetChildren()) do
        if d.Name == "WarningDisk" and d.Size.X <= 8 then
            if not d:GetAttribute("SpawnTime") then d:SetAttribute("SpawnTime", tick()) end
            table.insert(n, d)
        end
    end
    table.sort(n, function(a,b) return (1-a.Transparency) > (1-b.Transparency) end)
    warningDisks.queue = n
end

local function processDisks()
    if warningDisks.processing or #warningDisks.queue == 0 then return end
    warningDisks.processing = true
    task.spawn(function()
        while #warningDisks.queue > 0 do
            local d = warningDisks.queue[1]
            if d and d.Parent then
                local spawnT = d:GetAttribute("SpawnTime") or tick()
                if d.Transparency > 0.05 then
                    local wait = 1.6 - (tick()-spawnT); if wait > 0 then task.wait(wait) end
                end
                if d and d.Parent then
                    local lootStart, timeout = nil, tick()
                    while d and d.Parent and (tick()-timeout < 3) do
                        teleportTo(d.Position + Vector3.new(0,1,0))
                        RepStorage.Events.ToolCollect:FireServer()
                        if d.Transparency <= 0.05 and not lootStart then lootStart = tick() end
                        if lootStart and (tick()-lootStart > 0.14) then break end
                        RunService.Heartbeat:Wait()
                    end
                end
            end
            table.remove(warningDisks.queue, 1); updateDisks()
        end
        warningDisks.processing = false
    end)
end

-- =============================================================================
-- [[ 9. BACKGROUND STATS & BOOSTER TASK ]]
-- =============================================================================
task.spawn(function()
    while _G.Running do
        task.wait(1)

        -- ---- Stats update ----
        local elapsed   = math.max(1, tick() - startTime)
        local honey     = LocalPlayer.CoreStats.Honey.Value - initialHoney
        local hps, pps  = honey/elapsed, totalPollenCollected/elapsed

        -- Interval stats
        local iElapsed  = math.max(1, tick() - intervalStartTime)
        local iHoney    = LocalPlayer.CoreStats.Honey.Value - intervalHoneyStart
        local ihps      = iHoney / iElapsed

        local displayHPS = showIntervalStats and ihps or hps

        if UI_Stats and UI_Stats.hS then
            UI_Stats.hS.Text    = "  H/s:  "..formatNumber(displayHPS)
            UI_Stats.hM.Text    = "  H/m:  "..formatNumber(displayHPS*60)
            UI_Stats.hH.Text    = "  H/h:  "..formatNumber(displayHPS*3600)
            UI_Stats.pS.Text    = "  P/s:  "..formatNumber(pps)
            UI_Stats.pM.Text    = "  P/m:  "..formatNumber(pps*60)
            UI_Stats.pH.Text    = "  P/h:  "..formatNumber(pps*3600)
            UI_Stats.total.Text = "  Total Honey:  "..formatNumber(honey)
            UI_Stats.time.Text  = "  Runtime:  "..os.date("!%X", elapsed)

            -- MM Rewards
            local mmLines = {}
            local assetCache = {}
            local function getNameCached(id)
                if assetCache[id] then return assetCache[id] end
                local ok, n = pcall(function() return MarketplaceService:GetProductInfo(tonumber(id), Enum.InfoType.Asset).Name end)
                assetCache[id] = ok and n or ("ID:"..id)
                return assetCache[id]
            end
            for id, cnt in pairs(totalMMRewards) do
                table.insert(mmLines, "  "..getNameCached(id)..": x"..cnt)
            end
            UI_Stats.mm.Text = #mmLines > 0 and table.concat(mmLines, "\n") or "  No rewards yet."

            if UI_Stats.fieldActive then
                UI_Stats.fieldActive.Text = "  Field: "..currentFieldName
            end

            -- Update timed balloon status in Cfg
            if ignoreBalloonUntil > 0 and tick() > ignoreBalloonUntil then
                ignoreBalloonUntil = 0
            end
        end

        -- ---- CSV telemetry ----
        local cP, cC = LocalPlayer.CoreStats.Pollen.Value, LocalPlayer.CoreStats.Capacity.Value
        table.insert(statsBuffer, string.format("%s,%d,%d,%d,%d,%d", os.date("%H:%M:%S"), LocalPlayer.CoreStats.Honey.Value, math.floor(hps), cP, math.floor(pps), cC))
        if tick()-lastSaveTime >= SAVE_INTERVAL then flushBuffers(); lastSaveTime=tick() end

        -- ---- Booster dispatch ----
        if isFarming and #boosterQueue > 0 and not isConvertingHoney and not activeBooster and not warningDisks.processing and not isSolvingMemoryMatch and not isCheckingBoosters then
            activeBooster = true
            local b = table.remove(boosterQueue, 1)
            if boosterUILabels[b] then
                boosterUILabels[b].Text = "  "..b..":  üîÑ Claiming"
                boosterUILabels[b].TextColor3 = Color3.fromRGB(80,180,255)
            end
            teleportTo(Boosters[b].pos); task.wait(1.5)
            -- Cancel any movement the humanoid queued up after the teleport
            local _char = LocalPlayer.Character
            local _hum  = _char and _char:FindFirstChild("Humanoid")
            local _hrp  = _char and _char:FindFirstChild("HumanoidRootPart")
            if _hum and _hrp then _hum:MoveTo(_hrp.Position) end
            pressEKey(); task.wait(0.5)

            if Boosters[b].isMM then
                -- Verify the board actually opened (no board = claim failed: on cooldown, cost gate, etc.)
                local boardFound = false
                local waitStart  = tick()
                while tick() - waitStart < 6 do
                    task.wait(0.25)
                    local sg2 = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
                    local ml  = sg2 and sg2:FindFirstChild("MinigameLayer")
                    if ml then
                        for _, child in pairs(ml:GetChildren()) do
                            if child.Name == "MemoryMatchFrame" then
                                local lbl = child:FindFirstChild("ChancesFrame") and child.ChancesFrame:FindFirstChild("CountLabel")
                                if lbl and (tonumber(string.match(lbl.ContentText or "", "%d+")) or 0) >= 1 then
                                    boardFound = true; break
                                end
                            end
                        end
                    end
                    if boardFound then break end
                end

                if boardFound then
                    ActiveMemoryMatchName = b
                    isSolvingMemoryMatch  = true
                    lastMMPress           = tick()
                    if boosterUILabels[b] then
                        boosterUILabels[b].Text = "  "..b..":  üß† Solving"
                        boosterUILabels[b].TextColor3 = Color3.fromRGB(180,120,255)
                    end
                else
                    -- Claim failed ‚Äî re-read button text for accurate cooldown
                    -- Handles both "x:xx:xx" style AND "Spend X,XXX,XXX honey to play ... (x:xx:xx)" style
                    local cooldownSecs = Boosters[b].time
                    local btn2 = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("ActivateButton")
                    if btn2 and btn2:FindFirstChild("TextBox") then
                        local btnTxt = btn2.TextBox.Text
                        local cd = parseCooldown(btnTxt)  -- parseCooldown already handles any x:xx:xx anywhere in string
                        if cd and cd > 0 then cooldownSecs = cd end
                    end
                    task.delay(cooldownSecs, function()
                        if not boosterPermaIgnore[b] then
                            table.insert(boosterQueue, b)
                            if boosterUILabels[b] then
                                boosterUILabels[b].Text = "  "..b..":  ‚úÖ READY"
                                boosterUILabels[b].TextColor3 = Color3.fromRGB(80,220,80)
                            end
                        end
                    end)
                    local timeStr = string.format("%dh %dm", math.floor(cooldownSecs/3600), math.floor((cooldownSecs%3600)/60))
                    if boosterUILabels[b] then
                        boosterUILabels[b].Text = "  "..b..":  ‚è≥ "..timeStr.." (skipped)"
                        boosterUILabels[b].TextColor3 = Color3.fromRGB(200,120,60)
                    end
                end
                -- re-queue on success is handled inside the MM solver thread after board closes
                activeBooster = false
                teleportTo(getFieldCenter())
            else
                if Boosters[b].collectibles then
                    local spawnTimeout = tick()
                    local function getNearby()
                        local c = {}
                        for _, t in ipairs(workspace.Collectibles:GetChildren()) do
                            if t:IsA("Part") and (t.Position - Boosters[b].pos).Magnitude < 30 then table.insert(c,t) end
                        end
                        return c
                    end
                    repeat task.wait(0.1) until #getNearby()>0 or tick()-spawnTimeout>6
                    local vacStart = tick()
                    while tick()-vacStart < 12 do
                        local n2 = getNearby(); if #n2==0 then break end
                        for _, t in ipairs(n2) do teleportTo(t.Position); task.wait(0.05) end
                    end
                end
                task.delay(Boosters[b].time, function()
                    if not boosterPermaIgnore[b] then
                        table.insert(boosterQueue, b)
                        if boosterUILabels[b] then
                            boosterUILabels[b].Text = "  "..b..":  ‚úÖ READY"
                            boosterUILabels[b].TextColor3 = Color3.fromRGB(80,220,80)
                        end
                    end
                end)
                if boosterUILabels[b] then
                    local timeStr = string.format("%dh %dm", math.floor(Boosters[b].time/3600), math.floor((Boosters[b].time%3600)/60))
                    boosterUILabels[b].Text = "  "..b..":  ‚è≥ "..timeStr
                    boosterUILabels[b].TextColor3 = Color3.fromRGB(200,180,60)
                end
                task.wait(1.5)
                activeBooster = false
                teleportTo(getFieldCenter())
            end
        end
    end
end)

-- =============================================================================
-- [[ 10. CORE FAILSAFES (Heartbeat) ]]
-- =============================================================================
table.insert(connections, RunService.Heartbeat:Connect(function()
    if not _G.Running then return end
    updateDisks()

    local char = LocalPlayer.Character
    local hrp  = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    -- Honey-making E-key press
    if isConvertingHoney then
        local activateBtn = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("ActivateButton")
        if activateBtn and activateBtn:FindFirstChild("TextBox") then
            if activateBtn.TextBox.Text:lower() == "make honey" and tick()-lastHoneyEPress > 5 then
                lastHoneyEPress = tick(); killMomentum(); pressEKey()
            end
        end
        local hPos = getHivePos()
        if hPos then
            local xzDist = Vector2.new(hrp.Position.X-hPos.X, hrp.Position.Z-hPos.Z).Magnitude
            local yDist  = math.abs(hrp.Position.Y-hPos.Y)
            if xzDist > 5 or yDist > 30 then teleportTo(hPos) end
        end
        return
    end

    -- Field boundary failsafe
    if isFarming and not isCheckingBoosters and not activeBooster and not isSolvingMemoryMatch then
        if not isWithinField(hrp.Position) then
            if tick()-lastTimeInField > 10 then teleportTo(getFieldCenter()); lastTimeInField=tick() end
        else
            lastTimeInField = tick()
        end
    end

    -- Clean up verifying tokens
    for t, time in pairs(verifyingTokens) do
        if not t.Parent or math.abs(t.Orientation.X)>20 or tick()-time>1.2 then
            verifyingTokens[t] = nil
        end
    end
end))

-- =============================================================================
-- [[ 11. MAIN FARMING LOOP (RenderStepped) ]]
-- =============================================================================
table.insert(connections, RunService.RenderStepped:Connect(function()
    if not _G.Running or not isFarming then return end

    local char = LocalPlayer.Character
    local hrp  = char and char:FindFirstChild("HumanoidRootPart")
    local hum  = char and char:FindFirstChild("Humanoid")
    if not hrp or isCheckingBoosters or activeBooster then return end

    -- Place sprinkler if we haven't for this field
    if sprinklerFieldName ~= currentFieldName then
        placeSprinkler()
    end

    if #warningDisks.queue > 0 or warningDisks.processing then processDisks(); return end

    local pol, cap = LocalPlayer.CoreStats.Pollen.Value, LocalPlayer.CoreStats.Capacity.Value

    if not isConvertingHoney then
        if pol >= cap then
            if not waitingForBees then
                waitingForBees = true; fullBagTime = tick()
                if tick()-lastEmptiedTime < 5 then quickRefillCounter += 1 else quickRefillCounter = 0 end
            end
            if quickRefillCounter >= 5 or (tick()-fullBagTime >= 5) then
                isConvertingHoney  = true
                waitingForBees     = false
                quickRefillCounter = 0
                local hP = getHivePos()
                if hP then
                    teleportTo(hP)
                    RepStorage.Events.ItemPackageEvent:InvokeServer("Equip", {["Category"]="Accessory", ["Type"]="Honey Mask"})
                    task.wait(1)
                    RepStorage.Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking")
                end
            end
        else
            if waitingForBees then waitingForBees=false; lastEmptiedTime=tick() end
        end
    else
        -- Balloon check: if pollen=0 and still in conversion, wait 5s then bail
        local shouldIgnoreBalloon = ignoreBalloonForever or (tick() < ignoreBalloonUntil)
        if not shouldIgnoreBalloon and pol == 0 then
            -- Check for nearby balloon
            local balloonNear = false
            local hPos2 = getHivePos()
            if hPos2 then
                local checkPos = hPos2
                local bal = workspace:FindFirstChild("Balloons")
                local hb  = bal and bal:FindFirstChild("HiveBalloons")
                if hb then
                    for _, inst in ipairs(hb:GetDescendants()) do
                        if inst.Name == "BalloonBody" and (inst.Position - checkPos).Magnitude < 30 then
                            balloonNear = true; break
                        end
                    end
                end
            end
            if balloonNear then
                task.wait(5)
                isConvertingHoney = false
                teleportTo(getFieldCenter())
                return
            end
        end

        -- Check if honey making finished
        local activateBtn = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("ActivateButton")
        if activateBtn and activateBtn:FindFirstChild("TextBox") then
            if activateBtn.TextBox.Text:find("Pollen From Flower Fields") then
                RepStorage.Events.ItemPackageEvent:InvokeServer("Equip", {["Category"]="Accessory", ["Type"]="Diamond Mask"})
                isConvertingHoney = false
                lastEmptiedTime   = tick()
                teleportTo(getFieldCenter())
            end
        end
        return
    end

    -- Collect
    RepStorage.Events.ToolCollect:FireServer()

    local res = {}
    for _, p in ipairs(workspace.Collectibles:GetChildren()) do
        if p:IsA("Part") and not verifyingTokens[p] and not permaIgnore[p] then
            if math.abs(p.Position.Y - hrp.Position.Y) > 5 then permaIgnore[p]=true; continue end
            if firstAttemptTimes[p] and (tick()-firstAttemptTimes[p] > 8) then permaIgnore[p]=true; continue end
            if isWithinField(p.Position) then
                table.insert(res, {part=p, priority=4, type="Token"})
            end
        end
    end
    for _, p in ipairs(workspace.Particles:GetChildren()) do
        if p.Name == "Crosshair" and not crosshairBlacklist[p] then
            crosshairCounter += 1
            if crosshairCounter % 3 == 0 then crosshairBlacklist[p] = true
            else table.insert(res, {part=p, priority=1, type="Crosshair"}) end
        end
    end
    table.sort(res, function(a,b) return a.priority < b.priority end)

    if not currentTarget or verifyingTokens[currentTarget] or not currentTarget.Parent then
        currentTarget     = #res>0 and res[1].part or nil
        currentTargetType = #res>0 and res[1].type or nil
        if currentTarget and not firstAttemptTimes[currentTarget] then
            firstAttemptTimes[currentTarget] = tick()
        end
    end

    if currentTarget then
        if currentTargetType == "Crosshair" then
            hum:MoveTo(currentTarget.Position)
            if (hrp.Position - currentTarget.Position).Magnitude < 3 then
                killMomentum()
                local t = tick()
                while currentTarget and currentTarget.Parent and tick()-t < 4 do
                    RepStorage.Events.ToolCollect:FireServer()
                    RunService.Heartbeat:Wait()
                end
                crosshairBlacklist[currentTarget] = true
                currentTarget = nil
            end
        else
            local pP, tP = hrp.Position, currentTarget.Position
            local dir = (tP - pP).Unit
            if dir.X ~= dir.X then dir = Vector3.new(0,0,-1) end
            local dest    = tP + dir*4
            local b       = getFieldBounds()
            local clamped = Vector3.new(math.clamp(dest.X,b.x1,b.x2), pP.Y, math.clamp(dest.Z,b.z1,b.z2))
            hum:MoveTo(clamped)
            if (pP-clamped).Magnitude < 2.5 or (pP-tP).Magnitude < 1.5 then
                verifyingTokens[currentTarget] = tick()
                currentTarget = nil
            end
        end
    else
        if not lastWanderPos or (hrp.Position-lastWanderPos).Magnitude < 5 or tick()-lastWanderTime > 8 then
            local b = getFieldBounds()
            lastWanderPos  = Vector3.new(math.random(b.x1,b.x2), hrp.Position.Y, math.random(b.z1,b.z2))
            lastWanderTime = tick()
        end
        hum:MoveTo(lastWanderPos)
    end
end))

-- =============================================================================
-- [[ 12. WEBHOOK (every 5 min) ]]
-- =============================================================================
task.spawn(function()
    while _G.Running do
        task.wait(300)
        local elapsed = math.max(1, tick()-startTime)
        local h       = LocalPlayer.CoreStats.Honey.Value - initialHoney
        local hps, pps = h/elapsed, totalPollenCollected/elapsed
        local embeds = {{
            title  = "BSS V22 UPDATE",
            color  = 0x00A2FF,
            fields = {
                {name="Honey (S/M/H)", value=string.format("%s | %s | %s", formatNumber(hps), formatNumber(hps*60), formatNumber(hps*3600))},
                {name="Pollen (S/M/H)", value=string.format("%s | %s | %s", formatNumber(pps), formatNumber(pps*60), formatNumber(pps*3600))},
                {name="Total Honey", value=formatNumber(h), inline=true},
                {name="Runtime", value=os.date("!%X",elapsed), inline=true},
                {name="Field", value=currentFieldName, inline=true}
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }}
        pcall(function()
            local req = (syn and syn.request) or (http and http.request) or request
            req({Url=Webhook_URL, Method='POST', Headers={['Content-Type']='application/json'}, Body=HttpService:JSONEncode({embeds=embeds})})
        end)
    end
end)

-- =============================================================================
-- [[ 13. TILE MONITOR ]]
-- =============================================================================
task.spawn(function()
    while _G.Running do
        task.wait(0.25)
        local grid = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("TileGrid")
        if grid then
            local current = {}
            for _, tile in ipairs(grid:GetChildren()) do
                if tile.Name=="IconTile" and tile:FindFirstChild("BG") and tile.BG:FindFirstChild("Icon") then
                    local id = tile.BG.Icon.Image:match("%d+")
                    if monitoredTiles[id] then
                        local tid  = "T"..id
                        local mult = (tile.BG:FindFirstChild("Text") and tile.BG.Text.ContentText~="" and tile.BG.Text.ContentText) or "x1"
                        current[tid] = true
                        if tileStates[tid] ~= mult then
                            tileStates[tid] = mult
                            table.insert(tilesBuffer, string.format("%s,%s,%s,Active", os.date("%H:%M:%S"), tid, mult))
                        end
                    end
                end
            end
            for tid in pairs(tileStates) do
                if not current[tid] then
                    tileStates[tid] = nil
                    table.insert(tilesBuffer, string.format("%s,%s,x0,Removed", os.date("%H:%M:%S"), tid))
                end
            end
        end
    end
end)

-- =============================================================================
-- [[ 14. ANTI-IDLE ]]
-- =============================================================================
table.insert(connections, LocalPlayer.Idled:Connect(function()
    VUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    task.wait(1)
    VUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
end))

print("‚úÖ BSS V22 loaded. Press START FARMING in the UI to begin.")
