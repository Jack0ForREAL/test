-- [[ INITIALIZATION ]]
if _G.Running then return end
_G.Running = true

local connections = {} 
local firstAttemptTimes, permaIgnore, verifyingTokens = {}, {}, {}
local totalPollenCollected, lastPollenRaw = 0, game.Players.LocalPlayer.CoreStats.Pollen.Value
local startTime, initialHoney = tick(), game.Players.LocalPlayer.CoreStats.Honey.Value
local lastHoneyEPress = 0 

-- External Libs
task.spawn(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    -- disabled cant edit loadstring(game:HttpGet("https://pastes.io/raw/deleteuseless"))()
    -- Wait for the game to fully load
if game:IsLoaded() then
    -- Destroy specific objects once
    local objectsToDestroy = {
        "FlowerZones", "Flowers", "Balloons.FieldBalloons", "Amulets", "Badge Guild",
        "BearShop1", "BoostBalls", "ClassicMinigame", "Decorations",
        "Goo", "Paths"
    }

    for _, objectName in ipairs(objectsToDestroy) do
        local object = game.Workspace:FindFirstChild(objectName, true)
        if object then
            object:Destroy()
        end
    end

    -- Destroy all parts that are DIRECTLY inside Workspace
    for _, instance in ipairs(game.Workspace:GetChildren()) do
        if instance:IsA("Part") then
            instance:Destroy()
        end
    end

    -- Continuously delete balloons inside FieldBalloons every second
    task.spawn(function()
        while true do
            local fieldBalloons = game.Workspace:FindFirstChild("Balloons")
            if fieldBalloons then
                local balloons = fieldBalloons:FindFirstChild("FieldBalloons")
                if balloons then
                    balloons:Destroy() -- Fixed capitalization
                end
            end
            task.wait(0.1) -- Wait 1 second before running again
        end
    end)
end
-------
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local VUser = game:GetService("VirtualUser")
local VInput = game:GetService("VirtualInputManager")

-- [[ CONFIGURATION ]]
local fieldBounds = {x1 = -375.75, y1 = 65, z1 = -251.95, x2 = -284.05, y2 = 75, z2 = -128.05}
local fieldCenter = Vector3.new(-330, 70, -190)
local Webhook_URL = "https://discord.com/api/webhooks/1328668957774839819/5-ooyV3yMEsU46cfNtF9NV8a0kyNA0u2Q4xXxeK5HEroIU5yCwqIcmq-8MM7V0bYGBwI"

local Boosters = {
    ["Blue Field Booster"] = { pos = Vector3.new(272, 59, 84), collectibles = false, time = 2700 },
    ["Wealth Clock"] = { pos = Vector3.new(330, 50, 191), collectibles = false, time = 3600 },
    ["Stockings"] = { pos = Vector3.new(232, 38, 232), collectibles = true, time = 3600 },
    ["Onett"] = { pos = Vector3.new(34, 236, -512), collectibles = true, time = 28800 },
    ["Glue Dispenser"] = { pos = Vector3.new(270, 25258, -722), collectibles = false, time = 79200 },
    ["Gingerbread House"] = { pos = Vector3.new(-201, 6, 96), collectibles = false, time = 7200 },
    ["Memory Match"] = { pos = Vector3.new(137, 69, -95), collectibles = false, time = 7200, isMM = true },
    ["Mega Memory Match"] = { pos = Vector3.new(-428, 70, -53), collectibles = false, time = 14400, isMM = true },
    ["Night Memory Match"] = { pos = Vector3.new(-17, 312, -270), collectibles = false, time = 28800, isMM = true },
    ["Extreme Memory Match"] = { pos = Vector3.new(-403, 111, 545), collectibles = false, time = 28800, isMM = true }
}

-- [[ STATE MANAGEMENT ]]
local warningDisks = { queue = {}, processing = false }
local crosshairCounter, crosshairBlacklist = 0, {}
local boosterQueue, boosterPermaIgnore = {}, {}
local isCheckingBoosters, isConvertingHoney, activeBooster = true, false, false
local quickRefillCounter, lastEmptiedTime, fullBagTime, waitingForBees = 0, tick(), 0, false
local lastTimeInField, lastWanderPos, lastWanderTime = tick(), nil, 0

-- Memory Match State
local isSolvingMemoryMatch = false
local ActiveMemoryMatchName = nil
local lastMMPress = 0

-- [[ CSV TELEMETRY SETUP ]]
local statsBuffer, tilesBuffer = {}, {}
local lastSaveTime = tick()
local SAVE_INTERVAL = 15
local tilesFilename = "Tiles.txt"

local function generateFilename(base)
    local date = os.date("*t")
    return string.format("%s-%d-%d-%d_%d%s.csv", base, date.year, date.month, date.day, date.hour, (date.hour < 12 and "am" or "pm"))
end
local statsFile, tilesOutputFile = generateFilename("TelementBSS"), generateFilename("TelementBSSTiles")

local function flushBuffers()
    if #statsBuffer > 0 then
        local data = table.concat(statsBuffer, "\n")
        if isfile(statsFile) then appendfile(statsFile, "\n" .. data) else writefile(statsFile, "Time,TotalHoney,HPS,Pollen,PPS,Capacity\n" .. data) end
        statsBuffer = {}
    end
    if #tilesBuffer > 0 then
        local data = table.concat(tilesBuffer, "\n")
        if isfile(tilesOutputFile) then appendfile(tilesOutputFile, "\n" .. data) else writefile(tilesOutputFile, "Time,TileID,Multiplier,State\n" .. data) end
        tilesBuffer = {}
    end
end

local function loadTileIDs()
    if not isfile(tilesFilename) then return {} end
    local ids = {}
    for line in readfile(tilesFilename):gmatch("%S+") do ids[line] = true end
    return ids
end
local monitoredTiles = loadTileIDs()
local tileStates = {}

-- [[ UTILITIES ]]
local function formatNumber(n) return tostring(math.floor(n)):reverse():gsub("%d%d%d", "%1,"):reverse():gsub("^,", "") end
local function killMomentum() local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart"); if hrp then hrp.Velocity, hrp.RotVelocity = Vector3.zero, Vector3.zero end end
local function teleportTo(pos) local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart"); if hrp then killMomentum(); hrp.CFrame = CFrame.new(pos) end end
local function isWithinField(pos) return pos.X >= fieldBounds.x1 and pos.X <= fieldBounds.x2 and pos.Z >= fieldBounds.z1 and pos.Z <= fieldBounds.z2 end

local function pressEKey()
    VInput:SendKeyEvent(true, Enum.KeyCode.E, false, game)
    task.wait(0.1)
    VInput:SendKeyEvent(false, Enum.KeyCode.E, false, game)
end

local function getHivePos()
    local h = workspace:FindFirstChild("Honeycombs")
    if not h then return nil end
    for _, v in ipairs(h:GetChildren()) do 
        local o = v:FindFirstChild("Display") and v.Display:FindFirstChild("Gui") and v.Display.Gui:FindFirstChild("Frame") and v.Display.Gui.Frame:FindFirstChild("OwnerName")
        if o and o.Text == LocalPlayer.Name then return v.Display.Position - Vector3.new(0, 25, 7) end 
    end
    return nil
end

local function parseCooldown(txt)
    local h,m,s = txt:match("(%d+):(%d+):(%d+)"); if h then return tonumber(h)*3600 + tonumber(m)*60 + tonumber(s) end
    local m2,s2 = txt:match("(%d+):(%d+)"); if m2 then return tonumber(m2)*60 + tonumber(s2) end
    return nil
end

-- [[ UI SYSTEM ]]
local function createUI()
    local sg = Instance.new("ScreenGui", LocalPlayer.PlayerGui); sg.Name = "BSS_Macro_UI"; sg.ResetOnSpawn = false
    local main = Instance.new("Frame", sg); main.Size = UDim2.new(0, 250, 0, 320); main.Position = UDim2.new(0.05, 0, 0.3, 0); main.BackgroundColor3 = Color3.fromRGB(15,15,15); main.BorderSizePixel = 0; main.Active = true; main.Draggable = true
    local uiScale = Instance.new("UIScale", main)
    local top = Instance.new("Frame", main); top.Size = UDim2.new(1,0,0,30); top.BackgroundColor3 = Color3.fromRGB(30,30,30); top.BorderSizePixel = 0
    local title = Instance.new("TextLabel", top); title.Size = UDim2.new(0.7,0,1,0); title.Text = "  BSS MASTER V14"; title.TextColor3 = Color3.new(1,1,1); title.BackgroundTransparency = 1; title.TextXAlignment = Enum.TextXAlignment.Left; title.Font = Enum.Font.Code
    local dBtn = Instance.new("TextButton", top); dBtn.Size = UDim2.new(0.25,0,0.8,0); dBtn.Position = UDim2.new(0.72,0,0.1,0); dBtn.BackgroundColor3 = Color3.fromRGB(180,40,40); dBtn.Text = "STOP"; dBtn.TextColor3 = Color3.new(1,1,1)
    local cont = Instance.new("Frame", main); cont.Size = UDim2.new(0.9,0,0.7,0); cont.Position = UDim2.new(0.05,0,0.12,0); cont.BackgroundTransparency = 1
    Instance.new("UIListLayout", cont).Padding = UDim.new(0,5)
    local function createL(txt, clr)
        local l = Instance.new("TextLabel", cont); l.Size = UDim2.new(1,0,0,18); l.Text = txt; l.TextColor3 = clr or Color3.new(1,1,1); l.BackgroundTransparency = 1; l.TextXAlignment = Enum.TextXAlignment.Left; l.Font = Enum.Font.Code; l.TextScaled = true; return l
    end
    local stats = {hS = createL("H/s: 0"), hM = createL("H/m: 0"), hH = createL("H/h: 0"), pS = createL("P/s: 0", Color3.fromRGB(0,170,255)), pM = createL("P/m: 0", Color3.fromRGB(0,170,255)), pH = createL("P/h: 0", Color3.fromRGB(0,170,255)), total = createL("Total: 0", Color3.new(1,0.8,0)), time = createL("Time: 00:00:00")}
    local scBox = Instance.new("TextBox", main); scBox.Size = UDim2.new(0.9,0,0,22); scBox.Position = UDim2.new(0.05,0,0.9,0); scBox.BackgroundColor3 = Color3.fromRGB(30,30,30); scBox.Text = "Scale: 1.0"; scBox.TextColor3 = Color3.new(1,1,1); scBox.Font = Enum.Font.Code
    scBox.FocusLost:Connect(function() local v = tonumber(scBox.Text:match("[%d%.]+")); if v then uiScale.Scale = math.clamp(v, 0.4, 2.5) end end)
    dBtn.MouseButton1Click:Connect(function() _G.Running = false; for _, c in pairs(connections) do c:Disconnect() end; sg:Destroy(); print("Macro Stopped.") end)
    return stats, sg
end
local UI_Stats, MainGui = createUI()

-- [[ GROSS POLLEN WATCHER ]]
table.insert(connections, RunService.Heartbeat:Connect(function()
    local cur = LocalPlayer.CoreStats.Pollen.Value
    if cur > lastPollenRaw then totalPollenCollected = totalPollenCollected + (cur - lastPollenRaw) end
    lastPollenRaw = cur
end))

-- [[ MEMORY LEAK CLEANUP ]]
task.spawn(function()
    while _G.Running do
        task.wait(30)
        local function purge(tbl)
            for k, _ in pairs(tbl) do
                if typeof(k) == "Instance" and not k.Parent then tbl[k] = nil end
            end
        end
        purge(permaIgnore); purge(firstAttemptTimes); purge(verifyingTokens); purge(crosshairBlacklist)
    end
end)

-- [[ INVISIBLE MEMORY MATCH SOLVER (STRICT IGNORE FIX) ]]
task.spawn(function()
    local KnownCards, SolvedSlots, CurrentBoard = {}, {}, nil
    local GlobalOrderCounter = 0
    local function getOrderCounter() GlobalOrderCounter = GlobalOrderCounter + 1; return GlobalOrderCounter end
    local DefaultBackID = "http://www.roblox.com/asset/?id=3690982763"

    local MMLogic = {
        ["Memory Match"] = {
            Ignore = { ["2028574353"]=true,["1471882621"]=true,["2863122826"]=true, ["8277901755"]=true },
            ListA = { ["1674871631_x5"]=true,["2529092020"]=true, ["2863468407"]=true, ["2584584968"]=true,["2545746569"]=true },
            ListB = { ["2504978518"]=true }
        },
        ["Mega Memory Match"] = {
            Ignore = {["2028574353"]=true, ["1471882621"]=true, ["2863122826"]=true,["8277901755"]=true, ["3012679515"]=true,["3030407727"]=true },
            ListA = {["1674871631_x3"]=true,["2863468407_x3"]=true, ["2545746569"]=true, ["2584584968"]=true,["2542899798"]=true, ["15482935937"]=true },
            ListB = { ["2504978518"]=true,["2319943273"]=true,["1674871631_x10"]=true }
        },
        ["Night Memory Match"] = {
            Ignore = {["2028574353"]=true, ["8277901755"]=true, ["2863122826"]=true },
            ListA = { ["2504978518"]=true,["2314214749"]=true, ["2319943273"]=true },
            ListB = { ["2676671613"]=true,["2028603146"]=true }
        },
        ["Extreme Memory Match"] = {
            Ignore = { ["2028574353"]=true,["1471882621"]=true, ["1838129169"]=true, ["8277901755"]=true },
            ListA = {["2319943273"]=true, ["2542899798"]=true, ["2542899798_x5"]=true,["3835877932"]=true },
            ListB = {["1471850677"]=true, ["1471849394"]=true,["15529301204"]=true,["2028603146"]=true }
        }
    }

    local function extractCount(text)
        if not text then return "" end
        local m = string.match(text:lower(), "x%d+")
        return m or ""
    end

    local function checkCategory(matchType, id, countText)
        local logic = MMLogic[matchType] or MMLogic["Memory Match"]
        local sig = id
        if countText and countText ~= "" then sig = id .. "_" .. countText end
        if logic.Ignore[sig] or logic.Ignore[id] then return "Ignore" end
        if logic.ListB[sig] or logic.ListB[id] then return "ListB" end
        if logic.ListA[sig] or logic.ListA[id] then return "ListA" end
        return "Common"
    end

    local function clickSlot(slot)
        for _, desc in pairs(slot:GetDescendants()) do
            if (desc:IsA("ImageButton") or desc:IsA("TextButton")) and getconnections then
                for _, conn in pairs(getconnections(desc.MouseButton1Click)) do conn:Fire() end
                for _, conn in pairs(getconnections(desc.Activated)) do conn:Fire() end
            end
        end
    end

    local function clickAndRead(slot)
        local targetImg = nil
        for _, desc in pairs(slot:GetDescendants()) do
            if desc.Name == "ObjImage" and desc:IsA("ImageLabel") and desc.Image == DefaultBackID then targetImg = desc; break end
        end
        clickSlot(slot)
        if targetImg then
            local waited = 0
            while targetImg.Image == DefaultBackID and waited < 3 do task.wait(0.1); waited = waited + 0.1 end
            if targetImg.Image ~= DefaultBackID then 
                local txtLbl2 = targetImg:FindFirstChild("TextCount")
                return string.match(targetImg.Image, "%d+"), (txtLbl2 and extractCount(txtLbl2.Text) or "")
            end
        else
            task.wait(0.5)
            for _, desc in pairs(slot:GetDescendants()) do
                if desc.Name == "ObjImage" and desc:IsA("ImageLabel") and string.match(desc.Image, "rbxassetid://") then 
                    local txtLbl2 = desc:FindFirstChild("TextCount")
                    return string.match(desc.Image, "%d+"), (txtLbl2 and extractCount(txtLbl2.Text) or "")
                end
            end
        end
        return nil, ""
    end

    local function getActiveBoard()
        local sg = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui")
        local ml = sg and sg:FindFirstChild("MinigameLayer")
        if not ml then return nil end
        for _, child in pairs(ml:GetChildren()) do
            if child.Name == "MemoryMatchFrame" then
                local lbl = child:FindFirstChild("ChancesFrame") and child.ChancesFrame:FindFirstChild("CountLabel")
                if lbl and (tonumber(string.match(lbl.ContentText, "%d+")) or 0) >= 1 then return child end
            end
        end
        return nil
    end

    local function determineNextAction(matchType, availableSlots)
        local listBMatches, listAMatches, commonMatches = {}, {}, {}
        local idToSlot = {}
        
        -- Sort Matches: Strictly IGNORE "Ignore" category
        for slot, data in pairs(KnownCards) do
            if not SolvedSlots[slot] and data.cat ~= "Ignore" then
                if idToSlot[data.sig] then
                    local pair = {c1 = idToSlot[data.sig], c2 = slot, order = KnownCards[idToSlot[data.sig]].orderSeen}
                    if data.cat == "ListB" then table.insert(listBMatches, pair)
                    elseif data.cat == "ListA" then table.insert(listAMatches, pair)
                    elseif data.cat == "Common" then table.insert(commonMatches, pair) end
                else
                    idToSlot[data.sig] = slot
                end
            end
        end
        
        table.sort(listBMatches, function(a,b) return a.order < b.order end)
        table.sort(listAMatches, function(a,b) return a.order < b.order end)
        table.sort(commonMatches, function(a,b) return a.order < b.order end)
        
        if #listBMatches > 0 then return "Match", listBMatches[1].c1, listBMatches[1].c2 end
        if #listAMatches > 0 then return "Match", listAMatches[1].c1, listAMatches[1].c2 end
        
        -- EXPLORE UNKNOWNS (Do not pick known Ignores)
        local unknowns = {}
        for _, s in ipairs(availableSlots) do if not KnownCards[s] then table.insert(unknowns, s) end end
        
        if #unknowns >= 2 then
            local u1 = table.remove(unknowns, math.random(1, #unknowns))
            local u2 = table.remove(unknowns, math.random(1, #unknowns))
            return "Explore", u1, u2
        elseif #unknowns == 1 then
            -- Fallback: If only 1 unknown left, pair with anything valid (not ignore)
            local u1 = unknowns[1]
            local anchor = nil
            for s, d in pairs(KnownCards) do if not SolvedSlots[s] and d.cat ~= "Ignore" then anchor = s; break end end
            if not anchor then anchor = availableSlots[1] == u1 and availableSlots[2] or availableSlots[1] end
            return "Explore", u1, anchor
        end
        
        -- If no unknowns and no high priority matches, take common match or just random valid slots
        if #commonMatches > 0 then return "Match", commonMatches[1].c1, commonMatches[1].c2 end
        
        -- Last Resort (Board full of ignores/solved): Pick 2 random available slots
        return "Random", availableSlots[1], availableSlots[2]
    end

    local function doTurn(matchType, action, slot1, slot2)
        if action == "Match" or action == "Random" then
            clickSlot(slot1); task.wait(0.2); clickSlot(slot2)
            SolvedSlots[slot1] = true; SolvedSlots[slot2] = true
            task.wait(1.2)
        elseif action == "Explore" then
            local id1, count1 = clickAndRead(slot1)
            if id1 then
                local sig1 = id1; if count1 ~= "" then sig1 = id1 .. "_" .. count1 end
                KnownCards[slot1] = {id = id1, count = count1, sig = sig1, cat = checkCategory(matchType, id1, count1), orderSeen = getOrderCounter()}
                
                local pairSlot
                -- Check match, but SKIP IGNORES
                if KnownCards[slot1].cat ~= "Ignore" then
                    for s, d in pairs(KnownCards) do if s ~= slot1 and not SolvedSlots[s] and d.sig == sig1 then pairSlot = s; break end end
                end
                
                if pairSlot then
                    clickSlot(pairSlot); SolvedSlots[slot1] = true; SolvedSlots[pairSlot] = true; task.wait(1.2)
                else
                    local id2, count2 = clickAndRead(slot2)
                    if id2 then
                        local sig2 = id2; if count2 ~= "" then sig2 = id2 .. "_" .. count2 end
                        KnownCards[slot2] = {id = id2, count = count2, sig = sig2, cat = checkCategory(matchType, id2, count2), orderSeen = getOrderCounter()}
                        if sig1 == sig2 and KnownCards[slot2].cat ~= "Ignore" then SolvedSlots[slot1] = true; SolvedSlots[slot2] = true end
                    end
                    task.wait(1.2)
                end
            else clickSlot(slot2); task.wait(1.2) end
        end
    end

    while _G.Running do
        task.wait(0.1)
        local activeBoard = getActiveBoard()
        if not activeBoard then
            if isSolvingMemoryMatch and tick() - lastMMPress > 5 then
                isSolvingMemoryMatch = false; ActiveMemoryMatchName = nil
                task.wait(5)
            end
            continue
        end
        
        lastMMPress = tick()
        if activeBoard ~= CurrentBoard then CurrentBoard = activeBoard; KnownCards = {}; SolvedSlots = {}; GlobalOrderCounter = 0; task.wait(1) end
        
        local grid = activeBoard:FindFirstChild("GuiGrid") and activeBoard.GuiGrid:FindFirstChild("GuiGrid")
        if not grid then task.wait(1) continue end
        
        local available = {}
        for _, child in pairs(grid:GetChildren()) do if child:IsA("Frame") and not SolvedSlots[child] then table.insert(available, child) end end
        if #available == 0 then task.wait(2) continue end
        
        local matchType = ActiveMemoryMatchName or "Memory Match"
        local action, slot1, slot2 = determineNextAction(matchType, available)
        doTurn(matchType, action, slot1, slot2)
    end
end)

-- [[ DISK ENGINE ]]
local function updateDisks()
    local p = workspace:FindFirstChild("Particles"); if not p then return end
    local n = {}
    for _, d in ipairs(p:GetChildren()) do
        if d.Name == "WarningDisk" and d.Size.X <= 8 then
            if not d:GetAttribute("SpawnTime") then d:SetAttribute("SpawnTime", tick()) end
            table.insert(n, d)
        end
    end
    table.sort(n, function(a, b) return (1 - a.Transparency) > (1 - b.Transparency) end)
    warningDisks.queue = n
end

local function processDisks()
    if warningDisks.processing or #warningDisks.queue == 0 then return end
    warningDisks.processing = true
    task.spawn(function()
        while #warningDisks.queue > 0 do
            local d = warningDisks.queue[1]
            if d and d.Parent then
                local spawn = d:GetAttribute("SpawnTime") or tick()
                if d.Transparency > 0.05 then
                    local wait = 1.6 - (tick() - spawn); if wait > 0 then task.wait(wait) end
                end
                if d and d.Parent then
                    local lootStart, timeout = nil, tick()
                    while d and d.Parent and (tick() - timeout < 3) do
                        teleportTo(d.Position + Vector3.new(0, 1, 0))
                        game:GetService("ReplicatedStorage").Events.ToolCollect:FireServer()
                        if d.Transparency <= 0.05 and not lootStart then lootStart = tick() end
                        if lootStart and (tick() - lootStart > 0.14) then break end
                        RunService.Heartbeat:Wait()
                    end
                end
            end
            table.remove(warningDisks.queue, 1); updateDisks()
        end
        warningDisks.processing = false
    end)
end

-- [[ CORE FAILSAFES ]]
table.insert(connections, RunService.Heartbeat:Connect(function()
    if not _G.Running then return end
    updateDisks()
    local char = LocalPlayer.Character; local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    if isConvertingHoney then
        local activateBtn = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("ActivateButton")
        if activateBtn and activateBtn:FindFirstChild("TextBox") then
            if activateBtn.TextBox.Text:lower() == "make honey" and tick() - lastHoneyEPress > 5 then
                lastHoneyEPress = tick(); killMomentum(); pressEKey()
            end
        end

        local hPos = getHivePos()
        if hPos then
            local xzDist = Vector2.new(hrp.Position.X - hPos.X, hrp.Position.Z - hPos.Z).Magnitude
            local yDist = math.abs(hrp.Position.Y - hPos.Y)
            if xzDist > 5 or yDist > 30 then teleportTo(hPos) end
        end
        return 
    end

    if not isCheckingBoosters and not activeBooster and not isSolvingMemoryMatch then
        if (hrp.Position.X < fieldBounds.x1 or hrp.Position.X > fieldBounds.x2 or hrp.Position.Z < fieldBounds.z1 or hrp.Position.Z > fieldBounds.z2) then
            if tick() - lastTimeInField > 10 then teleportTo(fieldCenter); lastTimeInField = tick() end
        else lastTimeInField = tick() end
    end

    for t, time in pairs(verifyingTokens) do if not t.Parent or math.abs(t.Orientation.X) > 20 or tick() - time > 1.2 then verifyingTokens[t] = nil end end
end))

-- [[ MAIN FARMING LOOP ]]
table.insert(connections, RunService.RenderStepped:Connect(function()
    if not _G.Running then return end
    local char = LocalPlayer.Character
    local hrp, hum = char and char:FindFirstChild("HumanoidRootPart"), char and char:FindFirstChild("Humanoid")
    if not hrp or isCheckingBoosters or activeBooster then return end

    if #warningDisks.queue > 0 or warningDisks.processing then processDisks(); return end

    local pol, cap = LocalPlayer.CoreStats.Pollen.Value, LocalPlayer.CoreStats.Capacity.Value
    if not isConvertingHoney then
        if pol >= cap then
            if not waitingForBees then 
                waitingForBees = true; fullBagTime = tick()
                if tick() - lastEmptiedTime < 5 then quickRefillCounter = quickRefillCounter + 1 else quickRefillCounter = 0 end
            end
            if quickRefillCounter >= 5 or (tick() - fullBagTime >= 5) then
                isConvertingHoney = true; waitingForBees = false; quickRefillCounter = 0
                local hP = getHivePos(); if hP then teleportTo(hP); game:GetService("ReplicatedStorage").Events.ItemPackageEvent:InvokeServer("Equip", {["Category"] = "Accessory", ["Type"] = "Honey Mask"}); task.wait(1); game:GetService("ReplicatedStorage").Events.PlayerHiveCommand:FireServer("ToggleHoneyMaking") end
            end
        else if waitingForBees then waitingForBees = false; lastEmptiedTime = tick() end end
    else
        if LocalPlayer.PlayerGui.ScreenGui.ActivateButton.TextBox.Text:find("Pollen From Flower Fields") then
            game:GetService("ReplicatedStorage").Events.ItemPackageEvent:InvokeServer("Equip", {["Category"] = "Accessory", ["Type"] = "Diamond Mask"}); isConvertingHoney = false; lastEmptiedTime = tick(); teleportTo(fieldCenter)
        end
        return
    end

    game:GetService("ReplicatedStorage").Events.ToolCollect:FireServer()
    local res = {}
    for _, p in ipairs(workspace.Collectibles:GetChildren()) do
        if p:IsA("Part") and not verifyingTokens[p] and not permaIgnore[p] then
            if math.abs(p.Position.Y - hrp.Position.Y) > 5 then permaIgnore[p] = true continue end
            if firstAttemptTimes[p] and (tick() - firstAttemptTimes[p] > 8) then permaIgnore[p] = true continue end
            if p.Position.X >= fieldBounds.x1 and p.Position.X <= fieldBounds.x2 and p.Position.Z >= fieldBounds.z1 and p.Position.Z <= fieldBounds.z2 then
                table.insert(res, {part = p, priority = 4, type = "Token"})
            end
        end
    end
    for _, p in ipairs(workspace.Particles:GetChildren()) do
        if p.Name == "Crosshair" and not crosshairBlacklist[p] then
            crosshairCounter = crosshairCounter + 1
            if crosshairCounter % 3 == 0 then crosshairBlacklist[p] = true else table.insert(res, {part = p, priority = 1, type = "Crosshair"}) end
        end
    end
    table.sort(res, function(a,b) return a.priority < b.priority end)

    if not currentTarget or verifyingTokens[currentTarget] or not currentTarget.Parent then
        currentTarget = #res > 0 and res[1].part or nil; currentTargetType = #res > 0 and res[1].type or nil
        if currentTarget and not firstAttemptTimes[currentTarget] then firstAttemptTimes[currentTarget] = tick() end
    end

    if currentTarget then
        if currentTargetType == "Crosshair" then
            hum:MoveTo(currentTarget.Position)
            if (hrp.Position - currentTarget.Position).Magnitude < 3 then
                killMomentum()
                local t = tick(); while currentTarget and currentTarget.Parent and tick() - t < 4 do 
                    game:GetService("ReplicatedStorage").Events.ToolCollect:FireServer(); RunService.Heartbeat:Wait() 
                end
                crosshairBlacklist[currentTarget] = true; currentTarget = nil
            end
        else
            local pP, tP = hrp.Position, currentTarget.Position; local dir = (tP - pP).Unit; if dir.X ~= dir.X then dir = Vector3.new(0,0,-1) end
            local dest = tP + (dir * 4); local clamped = Vector3.new(math.clamp(dest.X, fieldBounds.x1, fieldBounds.x2), pP.Y, math.clamp(dest.Z, fieldBounds.z1, fieldBounds.z2))
            hum:MoveTo(clamped)
            if (pP - clamped).Magnitude < 2.5 or (pP - tP).Magnitude < 1.5 then verifyingTokens[currentTarget] = tick(); currentTarget = nil end
        end
    else
        if not lastWanderPos or (hrp.Position - lastWanderPos).Magnitude < 5 or tick() - lastWanderTime > 8 then lastWanderPos = Vector3.new(math.random(fieldBounds.x1, fieldBounds.x2), hrp.Position.Y, math.random(fieldBounds.z1, fieldBounds.z2)); lastWanderTime = tick() end
        hum:MoveTo(lastWanderPos)
    end
end))

-- [[ BACKGROUND STATS & BOOSTER TASK ]]
local function parseCooldown(txt)
    local h,m,s = txt:match("(%d+):(%d+):(%d+)"); if h then return tonumber(h)*3600 + tonumber(m)*60 + tonumber(s) end
    local m2,s2 = txt:match("(%d+):(%d+)"); if m2 then return tonumber(m2)*60 + tonumber(s2) end
    return nil
end

task.spawn(function()
    local btn = LocalPlayer.PlayerGui:WaitForChild("ScreenGui"):WaitForChild("ActivateButton")
    for name, data in pairs(Boosters) do
        teleportTo(data.pos); task.wait(1.8)
        local bg, txt = btn.BackgroundColor3, btn.TextBox.Text; local cd = parseCooldown(txt)
        if math.round(bg.R*255) == 201 and not cd then boosterPermaIgnore[name] = true
        elseif cd then task.delay(cd, function() if not boosterPermaIgnore[name] then table.insert(boosterQueue, name) end end)
        else table.insert(boosterQueue, name) end
    end
    isCheckingBoosters = false; teleportTo(fieldCenter)
    
    while _G.Running do
        task.wait(1); local elapsed = math.max(1, tick() - startTime); local h = LocalPlayer.CoreStats.Honey.Value - initialHoney
        local hps, pps = h/elapsed, totalPollenCollected/elapsed
        
        UI_Stats.hS.Text = "H/s: "..formatNumber(hps); UI_Stats.hM.Text = "H/m: "..formatNumber(hps*60); UI_Stats.hH.Text = "H/h: "..formatNumber(hps*3600)
        UI_Stats.pS.Text = "P/s: "..formatNumber(pps); UI_Stats.pM.Text = "P/m: "..formatNumber(pps*60); UI_Stats.pH.Text = "P/h: "..formatNumber(pps*3600)
        UI_Stats.total.Text = "Total: "..formatNumber(h); UI_Stats.time.Text = "Time: "..os.date("!%X", elapsed)
        
        local cP, cC = LocalPlayer.CoreStats.Pollen.Value, LocalPlayer.CoreStats.Capacity.Value
        table.insert(statsBuffer, string.format("%s,%d,%d,%d,%d,%d", os.date("%H:%M:%S"), LocalPlayer.CoreStats.Honey.Value, hps, cP, pps, cC))
        if tick() - lastSaveTime >= SAVE_INTERVAL then flushBuffers(); lastSaveTime = tick() end

        if #boosterQueue > 0 and not isConvertingHoney and not activeBooster and not warningDisks.processing and not isSolvingMemoryMatch then
            activeBooster = true; local b = table.remove(boosterQueue, 1); teleportTo(Boosters[b].pos)
            
            -- DOUBLE CHECK COOLDOWN ON ARRIVAL
            task.wait(1.5)
            local checkBtn = LocalPlayer.PlayerGui:FindFirstChild("ScreenGui") and LocalPlayer.PlayerGui.ScreenGui:FindFirstChild("ActivateButton")
            local currentTxt = checkBtn and checkBtn:FindFirstChild("TextBox") and checkBtn.TextBox.Text or ""
            local currentBg = checkBtn and checkBtn.BackgroundColor3
            local currentCd = parseCooldown(currentTxt)
            
            if currentBg and math.round(currentBg.R*255) == 201 and not currentCd then
                -- Red, no time: Ignore
                boosterPermaIgnore[b] = true
                activeBooster = false
            elseif currentCd then
                -- Has cooldown: Reschedule
                task.delay(currentCd, function() if not boosterPermaIgnore[b] then table.insert(boosterQueue, b) end end)
                activeBooster = false
            else
                -- Ready to use
                pressEKey(); task.wait(0.5)
                if Boosters[b].isMM then
                    task.wait(4)
                    ActiveMemoryMatchName = b; isSolvingMemoryMatch = true; lastMMPress = tick()
                    task.delay(Boosters[b].time, function() if not boosterPermaIgnore[b] then table.insert(boosterQueue, b) end end)
                    activeBooster = false; teleportTo(fieldCenter)
                else
                    if Boosters[b].collectibles then
                        local spawnTimeout = tick()
                        local function getNearby()
                            local c = {}
                            for _, t in ipairs(workspace.Collectibles:GetChildren()) do if t:IsA("Part") and (t.Position - Boosters[b].pos).Magnitude < 30 then table.insert(c, t) end end
                            return c
                        end
                        repeat task.wait(0.1) until #getNearby() > 0 or tick() - spawnTimeout > 6
                        local vacStart = tick()
                        while tick() - vacStart < 12 do
                            local n = getNearby(); if #n == 0 then break end
                            for _, t in ipairs(n) do teleportTo(t.Position); task.wait(0.05) end
                        end
                    end
                    task.delay(Boosters[b].time, function() if not boosterPermaIgnore[b] then table.insert(boosterQueue, b) end end)
                    task.wait(1.5); activeBooster = false; teleportTo(fieldCenter)
                end
            end
        end
    end
end)

-- [[ WEBHOOK ]]
task.spawn(function()
    while _G.Running do task.wait(300); local elapsed = math.max(1, tick() - startTime); local h = LocalPlayer.CoreStats.Honey.Value - initialHoney; local hps, pps = h/elapsed, totalPollenCollected/elapsed
        local embeds = {{title = "BSS MASTER UPDATE", color = 0x00A2FF, fields = {{name = "Honey (S/M/H)", value = string.format("%s | %s | %s", formatNumber(hps), formatNumber(hps*60), formatNumber(hps*3600))}, {name = "Pollen (S/M/H)", value = string.format("%s | %s | %s", formatNumber(pps), formatNumber(pps*60), formatNumber(pps*3600))}, {name = "Total Honey", value = formatNumber(h), inline = true}, {name = "Runtime", value = os.date("!%X", elapsed), inline = true}}, timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")}}
        pcall(function() local req = (syn and syn.request) or (http and http.request) or request; req({Url = Webhook_URL, Method = 'POST', Headers = {['Content-Type']='application/json'}, Body = HttpService:JSONEncode({embeds = embeds})}) end)
    end
end)

-- Anti-Idle
table.insert(connections, LocalPlayer.Idled:Connect(function() VUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame); task.wait(1); VUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame) end))
teleportTo(fieldCenter)
